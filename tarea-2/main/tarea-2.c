#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "driver/i2c.h"
#include "sdkconfig.h"
#include "math.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/uart.h"

int DEBUG = 1;

// I2C
#define I2C_MASTER_SCL_IO				GPIO_NUM_22				//GPIO pin
#define I2C_MASTER_SDA_IO				GPIO_NUM_21				//GPIO pin
#define I2C_MASTER_FREQ_HZ					10000		
#define ESP_SLAVE_ADDR_BMI					0x68 
#define ESP_SLAVE_ADDR_BME					0x76 
#define WRITE_BIT				0x0
#define READ_BIT				0x1
#define ACK_CHECK_EN			0x0
#define EXAMPLE_I2C_ACK_CHECK_DIS			0x0
#define ACK_VAL					0x0
#define NACK_VAL				0x1
// UART
#define BUF_SIZE (128) // buffer size https://stackoverflow.com/questions/9081479/is-there-a-good-reason-for-always-enclosing-a-define-in-parentheses-in-c
#define TXD_PIN 1  // UART TX pin
#define RXD_PIN 3  // UART RX pin
#define UART_NUM UART_NUM_0   // UART port number
#define BAUD_RATE 115200   // Baud rate

#define REDIRECT_LOGS 1 // if redirect ESP log to another UART

/* Macro to combine two 8 bit data's to form a 16 bit data */
#define BME68X_CONCAT_BYTES(msb, lsb)             (((uint16_t)msb << 8) | (uint16_t)lsb)

#define BME68X_OK 0

esp_err_t ret = ESP_OK;
esp_err_t ret2 = ESP_OK;

/*
 * @brief Sensor field data structure
 */
typedef struct bme68x_data {
    /*! Contains new_data, gasm_valid & heat_stab */
    uint8_t status;

    /*! The index of the heater profile used */
    uint8_t gas_index;

    /*! Measurement index to track order */
    uint8_t meas_index;

    /*! Heater resistance */
    uint8_t res_heat;

    /*! Current DAC */
    uint8_t idac;

    /*! Gas wait period */
    uint8_t gas_wait;

    /*! Temperature in degree celsius x100 */
    int32_t temperature;

    /*! Pressure in Pascal */
    uint32_t pressure;

    /*! Humidity in % relative humidity x1000 */
    uint32_t humidity;

    /*! Gas resistance in Ohms */
    uint32_t gas_resistance;

} bme68x_data;
// Usado por calc_temperature y calc_pressure
int32_t t_fine;

uint16_t val0[6];

/*! @name  Global array that stores the configuration file of BMI270 */
const uint8_t bmi270_config_file[] = {
    0xc8, 0x2e, 0x00, 0x2e, 0x80, 0x2e, 0x3d, 0xb1, 0xc8, 0x2e, 0x00, 0x2e, 0x80, 0x2e, 0x91, 0x03, 0x80, 0x2e, 0xbc,
    0xb0, 0x80, 0x2e, 0xa3, 0x03, 0xc8, 0x2e, 0x00, 0x2e, 0x80, 0x2e, 0x00, 0xb0, 0x50, 0x30, 0x21, 0x2e, 0x59, 0xf5,
    0x10, 0x30, 0x21, 0x2e, 0x6a, 0xf5, 0x80, 0x2e, 0x3b, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x19, 0x01, 0x00, 0x22,
    0x00, 0x75, 0x00, 0x00, 0x10, 0x00, 0x10, 0xd1, 0x00, 0xb3, 0x43, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0xe0, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x19, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
    0xe0, 0xaa, 0x38, 0x05, 0xe0, 0x90, 0x30, 0xfa, 0x00, 0x96, 0x00, 0x4b, 0x09, 0x11, 0x00, 0x11, 0x00, 0x02, 0x00,
    0x2d, 0x01, 0xd4, 0x7b, 0x3b, 0x01, 0xdb, 0x7a, 0x04, 0x00, 0x3f, 0x7b, 0xcd, 0x6c, 0xc3, 0x04, 0x85, 0x09, 0xc3,
    0x04, 0xec, 0xe6, 0x0c, 0x46, 0x01, 0x00, 0x27, 0x00, 0x19, 0x00, 0x96, 0x00, 0xa0, 0x00, 0x01, 0x00, 0x0c, 0x00,
    0xf0, 0x3c, 0x00, 0x01, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x32, 0x00, 0x05, 0x00, 0xee,
    0x06, 0x04, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x04, 0x00, 0xa8, 0x05, 0xee, 0x06, 0x00, 0x04, 0xbc, 0x02, 0xb3, 0x00,
    0x85, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xb4, 0x00, 0x01, 0x00, 0xb9, 0x00, 0x01, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x80, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x2e, 0x00, 0xc1, 0xfd, 0x2d, 0xde,
    0x00, 0xeb, 0x00, 0xda, 0x00, 0x00, 0x0c, 0xff, 0x0f, 0x00, 0x04, 0xc0, 0x00, 0x5b, 0xf5, 0xc9, 0x01, 0x1e, 0xf2,
    0x80, 0x00, 0x3f, 0xff, 0x19, 0xf4, 0x58, 0xf5, 0x66, 0xf5, 0x64, 0xf5, 0xc0, 0xf1, 0xf0, 0x00, 0xe0, 0x00, 0xcd,
    0x01, 0xd3, 0x01, 0xdb, 0x01, 0xff, 0x7f, 0xff, 0x01, 0xe4, 0x00, 0x74, 0xf7, 0xf3, 0x00, 0xfa, 0x00, 0xff, 0x3f,
    0xca, 0x03, 0x6c, 0x38, 0x56, 0xfe, 0x44, 0xfd, 0xbc, 0x02, 0xf9, 0x06, 0x00, 0xfc, 0x12, 0x02, 0xae, 0x01, 0x58,
    0xfa, 0x9a, 0xfd, 0x77, 0x05, 0xbb, 0x02, 0x96, 0x01, 0x95, 0x01, 0x7f, 0x01, 0x82, 0x01, 0x89, 0x01, 0x87, 0x01,
    0x88, 0x01, 0x8a, 0x01, 0x8c, 0x01, 0x8f, 0x01, 0x8d, 0x01, 0x92, 0x01, 0x91, 0x01, 0xdd, 0x00, 0x9f, 0x01, 0x7e,
    0x01, 0xdb, 0x00, 0xb6, 0x01, 0x70, 0x69, 0x26, 0xd3, 0x9c, 0x07, 0x1f, 0x05, 0x9d, 0x00, 0x00, 0x08, 0xbc, 0x05,
    0x37, 0xfa, 0xa2, 0x01, 0xaa, 0x01, 0xa1, 0x01, 0xa8, 0x01, 0xa0, 0x01, 0xa8, 0x05, 0xb4, 0x01, 0xb4, 0x01, 0xce,
    0x00, 0xd0, 0x00, 0xfc, 0x00, 0xc5, 0x01, 0xff, 0xfb, 0xb1, 0x00, 0x00, 0x38, 0x00, 0x30, 0xfd, 0xf5, 0xfc, 0xf5,
    0xcd, 0x01, 0xa0, 0x00, 0x5f, 0xff, 0x00, 0x40, 0xff, 0x00, 0x00, 0x80, 0x6d, 0x0f, 0xeb, 0x00, 0x7f, 0xff, 0xc2,
    0xf5, 0x68, 0xf7, 0xb3, 0xf1, 0x67, 0x0f, 0x5b, 0x0f, 0x61, 0x0f, 0x80, 0x0f, 0x58, 0xf7, 0x5b, 0xf7, 0x83, 0x0f,
    0x86, 0x00, 0x72, 0x0f, 0x85, 0x0f, 0xc6, 0xf1, 0x7f, 0x0f, 0x6c, 0xf7, 0x00, 0xe0, 0x00, 0xff, 0xd1, 0xf5, 0x87,
    0x0f, 0x8a, 0x0f, 0xff, 0x03, 0xf0, 0x3f, 0x8b, 0x00, 0x8e, 0x00, 0x90, 0x00, 0xb9, 0x00, 0x2d, 0xf5, 0xca, 0xf5,
    0xcb, 0x01, 0x20, 0xf2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x50, 0x98, 0x2e,
    0xd7, 0x0e, 0x50, 0x32, 0x98, 0x2e, 0xfa, 0x03, 0x00, 0x30, 0xf0, 0x7f, 0x00, 0x2e, 0x00, 0x2e, 0xd0, 0x2e, 0x00,
    0x2e, 0x01, 0x80, 0x08, 0xa2, 0xfb, 0x2f, 0x98, 0x2e, 0xba, 0x03, 0x21, 0x2e, 0x19, 0x00, 0x01, 0x2e, 0xee, 0x00,
    0x00, 0xb2, 0x07, 0x2f, 0x01, 0x2e, 0x19, 0x00, 0x00, 0xb2, 0x03, 0x2f, 0x01, 0x50, 0x03, 0x52, 0x98, 0x2e, 0x07,
    0xcc, 0x01, 0x2e, 0xdd, 0x00, 0x00, 0xb2, 0x27, 0x2f, 0x05, 0x2e, 0x8a, 0x00, 0x05, 0x52, 0x98, 0x2e, 0xc7, 0xc1,
    0x03, 0x2e, 0xe9, 0x00, 0x40, 0xb2, 0xf0, 0x7f, 0x08, 0x2f, 0x01, 0x2e, 0x19, 0x00, 0x00, 0xb2, 0x04, 0x2f, 0x00,
    0x30, 0x21, 0x2e, 0xe9, 0x00, 0x98, 0x2e, 0xb4, 0xb1, 0x01, 0x2e, 0x18, 0x00, 0x00, 0xb2, 0x10, 0x2f, 0x05, 0x50,
    0x98, 0x2e, 0x4d, 0xc3, 0x05, 0x50, 0x98, 0x2e, 0x5a, 0xc7, 0x98, 0x2e, 0xf9, 0xb4, 0x98, 0x2e, 0x54, 0xb2, 0x98,
    0x2e, 0x67, 0xb6, 0x98, 0x2e, 0x17, 0xb2, 0x10, 0x30, 0x21, 0x2e, 0x77, 0x00, 0x01, 0x2e, 0xef, 0x00, 0x00, 0xb2,
    0x04, 0x2f, 0x98, 0x2e, 0x7a, 0xb7, 0x00, 0x30, 0x21, 0x2e, 0xef, 0x00, 0x01, 0x2e, 0xd4, 0x00, 0x04, 0xae, 0x0b,
    0x2f, 0x01, 0x2e, 0xdd, 0x00, 0x00, 0xb2, 0x07, 0x2f, 0x05, 0x52, 0x98, 0x2e, 0x8e, 0x0e, 0x00, 0xb2, 0x02, 0x2f,
    0x10, 0x30, 0x21, 0x2e, 0x7d, 0x00, 0x01, 0x2e, 0x7d, 0x00, 0x00, 0x90, 0x90, 0x2e, 0xf1, 0x02, 0x01, 0x2e, 0xd7,
    0x00, 0x00, 0xb2, 0x04, 0x2f, 0x98, 0x2e, 0x2f, 0x0e, 0x00, 0x30, 0x21, 0x2e, 0x7b, 0x00, 0x01, 0x2e, 0x7b, 0x00,
    0x00, 0xb2, 0x12, 0x2f, 0x01, 0x2e, 0xd4, 0x00, 0x00, 0x90, 0x02, 0x2f, 0x98, 0x2e, 0x1f, 0x0e, 0x09, 0x2d, 0x98,
    0x2e, 0x81, 0x0d, 0x01, 0x2e, 0xd4, 0x00, 0x04, 0x90, 0x02, 0x2f, 0x50, 0x32, 0x98, 0x2e, 0xfa, 0x03, 0x00, 0x30,
    0x21, 0x2e, 0x7b, 0x00, 0x01, 0x2e, 0x7c, 0x00, 0x00, 0xb2, 0x90, 0x2e, 0x09, 0x03, 0x01, 0x2e, 0x7c, 0x00, 0x01,
    0x31, 0x01, 0x08, 0x00, 0xb2, 0x04, 0x2f, 0x98, 0x2e, 0x47, 0xcb, 0x10, 0x30, 0x21, 0x2e, 0x77, 0x00, 0x81, 0x30,
    0x01, 0x2e, 0x7c, 0x00, 0x01, 0x08, 0x00, 0xb2, 0x61, 0x2f, 0x03, 0x2e, 0x89, 0x00, 0x01, 0x2e, 0xd4, 0x00, 0x98,
    0xbc, 0x98, 0xb8, 0x05, 0xb2, 0x0f, 0x58, 0x23, 0x2f, 0x07, 0x90, 0x09, 0x54, 0x00, 0x30, 0x37, 0x2f, 0x15, 0x41,
    0x04, 0x41, 0xdc, 0xbe, 0x44, 0xbe, 0xdc, 0xba, 0x2c, 0x01, 0x61, 0x00, 0x0f, 0x56, 0x4a, 0x0f, 0x0c, 0x2f, 0xd1,
    0x42, 0x94, 0xb8, 0xc1, 0x42, 0x11, 0x30, 0x05, 0x2e, 0x6a, 0xf7, 0x2c, 0xbd, 0x2f, 0xb9, 0x80, 0xb2, 0x08, 0x22,
    0x98, 0x2e, 0xc3, 0xb7, 0x21, 0x2d, 0x61, 0x30, 0x23, 0x2e, 0xd4, 0x00, 0x98, 0x2e, 0xc3, 0xb7, 0x00, 0x30, 0x21,
    0x2e, 0x5a, 0xf5, 0x18, 0x2d, 0xe1, 0x7f, 0x50, 0x30, 0x98, 0x2e, 0xfa, 0x03, 0x0f, 0x52, 0x07, 0x50, 0x50, 0x42,
    0x70, 0x30, 0x0d, 0x54, 0x42, 0x42, 0x7e, 0x82, 0xe2, 0x6f, 0x80, 0xb2, 0x42, 0x42, 0x05, 0x2f, 0x21, 0x2e, 0xd4,
    0x00, 0x10, 0x30, 0x98, 0x2e, 0xc3, 0xb7, 0x03, 0x2d, 0x60, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0x01, 0x2e, 0xd4, 0x00,
    0x06, 0x90, 0x18, 0x2f, 0x01, 0x2e, 0x76, 0x00, 0x0b, 0x54, 0x07, 0x52, 0xe0, 0x7f, 0x98, 0x2e, 0x7a, 0xc1, 0xe1,
    0x6f, 0x08, 0x1a, 0x40, 0x30, 0x08, 0x2f, 0x21, 0x2e, 0xd4, 0x00, 0x20, 0x30, 0x98, 0x2e, 0xaf, 0xb7, 0x50, 0x32,
    0x98, 0x2e, 0xfa, 0x03, 0x05, 0x2d, 0x98, 0x2e, 0x38, 0x0e, 0x00, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0x00, 0x30, 0x21,
    0x2e, 0x7c, 0x00, 0x18, 0x2d, 0x01, 0x2e, 0xd4, 0x00, 0x03, 0xaa, 0x01, 0x2f, 0x98, 0x2e, 0x45, 0x0e, 0x01, 0x2e,
    0xd4, 0x00, 0x3f, 0x80, 0x03, 0xa2, 0x01, 0x2f, 0x00, 0x2e, 0x02, 0x2d, 0x98, 0x2e, 0x5b, 0x0e, 0x30, 0x30, 0x98,
    0x2e, 0xce, 0xb7, 0x00, 0x30, 0x21, 0x2e, 0x7d, 0x00, 0x50, 0x32, 0x98, 0x2e, 0xfa, 0x03, 0x01, 0x2e, 0x77, 0x00,
    0x00, 0xb2, 0x24, 0x2f, 0x98, 0x2e, 0xf5, 0xcb, 0x03, 0x2e, 0xd5, 0x00, 0x11, 0x54, 0x01, 0x0a, 0xbc, 0x84, 0x83,
    0x86, 0x21, 0x2e, 0xc9, 0x01, 0xe0, 0x40, 0x13, 0x52, 0xc4, 0x40, 0x82, 0x40, 0xa8, 0xb9, 0x52, 0x42, 0x43, 0xbe,
    0x53, 0x42, 0x04, 0x0a, 0x50, 0x42, 0xe1, 0x7f, 0xf0, 0x31, 0x41, 0x40, 0xf2, 0x6f, 0x25, 0xbd, 0x08, 0x08, 0x02,
    0x0a, 0xd0, 0x7f, 0x98, 0x2e, 0xa8, 0xcf, 0x06, 0xbc, 0xd1, 0x6f, 0xe2, 0x6f, 0x08, 0x0a, 0x80, 0x42, 0x98, 0x2e,
    0x58, 0xb7, 0x00, 0x30, 0x21, 0x2e, 0xee, 0x00, 0x21, 0x2e, 0x77, 0x00, 0x21, 0x2e, 0xdd, 0x00, 0x80, 0x2e, 0xf4,
    0x01, 0x1a, 0x24, 0x22, 0x00, 0x80, 0x2e, 0xec, 0x01, 0x10, 0x50, 0xfb, 0x7f, 0x98, 0x2e, 0xf3, 0x03, 0x57, 0x50,
    0xfb, 0x6f, 0x01, 0x30, 0x71, 0x54, 0x11, 0x42, 0x42, 0x0e, 0xfc, 0x2f, 0xc0, 0x2e, 0x01, 0x42, 0xf0, 0x5f, 0x80,
    0x2e, 0x00, 0xc1, 0xfd, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9a, 0x01,
    0x34, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x20, 0x50, 0xe7, 0x7f, 0xf6, 0x7f, 0x06, 0x32, 0x0f, 0x2e, 0x61, 0xf5, 0xfe, 0x09, 0xc0, 0xb3, 0x04,
    0x2f, 0x17, 0x30, 0x2f, 0x2e, 0xef, 0x00, 0x2d, 0x2e, 0x61, 0xf5, 0xf6, 0x6f, 0xe7, 0x6f, 0xe0, 0x5f, 0xc8, 0x2e,
    0x20, 0x50, 0xe7, 0x7f, 0xf6, 0x7f, 0x46, 0x30, 0x0f, 0x2e, 0xa4, 0xf1, 0xbe, 0x09, 0x80, 0xb3, 0x06, 0x2f, 0x0d,
    0x2e, 0xd4, 0x00, 0x84, 0xaf, 0x02, 0x2f, 0x16, 0x30, 0x2d, 0x2e, 0x7b, 0x00, 0x86, 0x30, 0x2d, 0x2e, 0x60, 0xf5,
    0xf6, 0x6f, 0xe7, 0x6f, 0xe0, 0x5f, 0xc8, 0x2e, 0x01, 0x2e, 0x77, 0xf7, 0x09, 0xbc, 0x0f, 0xb8, 0x00, 0xb2, 0x10,
    0x50, 0xfb, 0x7f, 0x10, 0x30, 0x0b, 0x2f, 0x03, 0x2e, 0x8a, 0x00, 0x96, 0xbc, 0x9f, 0xb8, 0x40, 0xb2, 0x05, 0x2f,
    0x03, 0x2e, 0x68, 0xf7, 0x9e, 0xbc, 0x9f, 0xb8, 0x40, 0xb2, 0x07, 0x2f, 0x03, 0x2e, 0x7e, 0x00, 0x41, 0x90, 0x01,
    0x2f, 0x98, 0x2e, 0xdc, 0x03, 0x03, 0x2c, 0x00, 0x30, 0x21, 0x2e, 0x7e, 0x00, 0xfb, 0x6f, 0xf0, 0x5f, 0xb8, 0x2e,
    0x20, 0x50, 0xe0, 0x7f, 0xfb, 0x7f, 0x00, 0x2e, 0x27, 0x50, 0x98, 0x2e, 0x3b, 0xc8, 0x29, 0x50, 0x98, 0x2e, 0xa7,
    0xc8, 0x01, 0x50, 0x98, 0x2e, 0x55, 0xcc, 0xe1, 0x6f, 0x2b, 0x50, 0x98, 0x2e, 0xe0, 0xc9, 0xfb, 0x6f, 0x00, 0x30,
    0xe0, 0x5f, 0x21, 0x2e, 0x7e, 0x00, 0xb8, 0x2e, 0x73, 0x50, 0x01, 0x30, 0x57, 0x54, 0x11, 0x42, 0x42, 0x0e, 0xfc,
    0x2f, 0xb8, 0x2e, 0x21, 0x2e, 0x59, 0xf5, 0x10, 0x30, 0xc0, 0x2e, 0x21, 0x2e, 0x4a, 0xf1, 0x90, 0x50, 0xf7, 0x7f,
    0xe6, 0x7f, 0xd5, 0x7f, 0xc4, 0x7f, 0xb3, 0x7f, 0xa1, 0x7f, 0x90, 0x7f, 0x82, 0x7f, 0x7b, 0x7f, 0x98, 0x2e, 0x35,
    0xb7, 0x00, 0xb2, 0x90, 0x2e, 0x97, 0xb0, 0x03, 0x2e, 0x8f, 0x00, 0x07, 0x2e, 0x91, 0x00, 0x05, 0x2e, 0xb1, 0x00,
    0x3f, 0xba, 0x9f, 0xb8, 0x01, 0x2e, 0xb1, 0x00, 0xa3, 0xbd, 0x4c, 0x0a, 0x05, 0x2e, 0xb1, 0x00, 0x04, 0xbe, 0xbf,
    0xb9, 0xcb, 0x0a, 0x4f, 0xba, 0x22, 0xbd, 0x01, 0x2e, 0xb3, 0x00, 0xdc, 0x0a, 0x2f, 0xb9, 0x03, 0x2e, 0xb8, 0x00,
    0x0a, 0xbe, 0x9a, 0x0a, 0xcf, 0xb9, 0x9b, 0xbc, 0x01, 0x2e, 0x97, 0x00, 0x9f, 0xb8, 0x93, 0x0a, 0x0f, 0xbc, 0x91,
    0x0a, 0x0f, 0xb8, 0x90, 0x0a, 0x25, 0x2e, 0x18, 0x00, 0x05, 0x2e, 0xc1, 0xf5, 0x2e, 0xbd, 0x2e, 0xb9, 0x01, 0x2e,
    0x19, 0x00, 0x31, 0x30, 0x8a, 0x04, 0x00, 0x90, 0x07, 0x2f, 0x01, 0x2e, 0xd4, 0x00, 0x04, 0xa2, 0x03, 0x2f, 0x01,
    0x2e, 0x18, 0x00, 0x00, 0xb2, 0x0c, 0x2f, 0x19, 0x50, 0x05, 0x52, 0x98, 0x2e, 0x4d, 0xb7, 0x05, 0x2e, 0x78, 0x00,
    0x80, 0x90, 0x10, 0x30, 0x01, 0x2f, 0x21, 0x2e, 0x78, 0x00, 0x25, 0x2e, 0xdd, 0x00, 0x98, 0x2e, 0x3e, 0xb7, 0x00,
    0xb2, 0x02, 0x30, 0x01, 0x30, 0x04, 0x2f, 0x01, 0x2e, 0x19, 0x00, 0x00, 0xb2, 0x00, 0x2f, 0x21, 0x30, 0x01, 0x2e,
    0xea, 0x00, 0x08, 0x1a, 0x0e, 0x2f, 0x23, 0x2e, 0xea, 0x00, 0x33, 0x30, 0x1b, 0x50, 0x0b, 0x09, 0x01, 0x40, 0x17,
    0x56, 0x46, 0xbe, 0x4b, 0x08, 0x4c, 0x0a, 0x01, 0x42, 0x0a, 0x80, 0x15, 0x52, 0x01, 0x42, 0x00, 0x2e, 0x01, 0x2e,
    0x18, 0x00, 0x00, 0xb2, 0x1f, 0x2f, 0x03, 0x2e, 0xc0, 0xf5, 0xf0, 0x30, 0x48, 0x08, 0x47, 0xaa, 0x74, 0x30, 0x07,
    0x2e, 0x7a, 0x00, 0x61, 0x22, 0x4b, 0x1a, 0x05, 0x2f, 0x07, 0x2e, 0x66, 0xf5, 0xbf, 0xbd, 0xbf, 0xb9, 0xc0, 0x90,
    0x0b, 0x2f, 0x1d, 0x56, 0x2b, 0x30, 0xd2, 0x42, 0xdb, 0x42, 0x01, 0x04, 0xc2, 0x42, 0x04, 0xbd, 0xfe, 0x80, 0x81,
    0x84, 0x23, 0x2e, 0x7a, 0x00, 0x02, 0x42, 0x02, 0x32, 0x25, 0x2e, 0x62, 0xf5, 0x05, 0x2e, 0xd6, 0x00, 0x81, 0x84,
    0x25, 0x2e, 0xd6, 0x00, 0x02, 0x31, 0x25, 0x2e, 0x60, 0xf5, 0x05, 0x2e, 0x8a, 0x00, 0x0b, 0x50, 0x90, 0x08, 0x80,
    0xb2, 0x0b, 0x2f, 0x05, 0x2e, 0xca, 0xf5, 0xf0, 0x3e, 0x90, 0x08, 0x25, 0x2e, 0xca, 0xf5, 0x05, 0x2e, 0x59, 0xf5,
    0xe0, 0x3f, 0x90, 0x08, 0x25, 0x2e, 0x59, 0xf5, 0x90, 0x6f, 0xa1, 0x6f, 0xb3, 0x6f, 0xc4, 0x6f, 0xd5, 0x6f, 0xe6,
    0x6f, 0xf7, 0x6f, 0x7b, 0x6f, 0x82, 0x6f, 0x70, 0x5f, 0xc8, 0x2e, 0xc0, 0x50, 0x90, 0x7f, 0xe5, 0x7f, 0xd4, 0x7f,
    0xc3, 0x7f, 0xb1, 0x7f, 0xa2, 0x7f, 0x87, 0x7f, 0xf6, 0x7f, 0x7b, 0x7f, 0x00, 0x2e, 0x01, 0x2e, 0x60, 0xf5, 0x60,
    0x7f, 0x98, 0x2e, 0x35, 0xb7, 0x02, 0x30, 0x63, 0x6f, 0x15, 0x52, 0x50, 0x7f, 0x62, 0x7f, 0x5a, 0x2c, 0x02, 0x32,
    0x1a, 0x09, 0x00, 0xb3, 0x14, 0x2f, 0x00, 0xb2, 0x03, 0x2f, 0x09, 0x2e, 0x18, 0x00, 0x00, 0x91, 0x0c, 0x2f, 0x43,
    0x7f, 0x98, 0x2e, 0x97, 0xb7, 0x1f, 0x50, 0x02, 0x8a, 0x02, 0x32, 0x04, 0x30, 0x25, 0x2e, 0x64, 0xf5, 0x15, 0x52,
    0x50, 0x6f, 0x43, 0x6f, 0x44, 0x43, 0x25, 0x2e, 0x60, 0xf5, 0xd9, 0x08, 0xc0, 0xb2, 0x36, 0x2f, 0x98, 0x2e, 0x3e,
    0xb7, 0x00, 0xb2, 0x06, 0x2f, 0x01, 0x2e, 0x19, 0x00, 0x00, 0xb2, 0x02, 0x2f, 0x50, 0x6f, 0x00, 0x90, 0x0a, 0x2f,
    0x01, 0x2e, 0x79, 0x00, 0x00, 0x90, 0x19, 0x2f, 0x10, 0x30, 0x21, 0x2e, 0x79, 0x00, 0x00, 0x30, 0x98, 0x2e, 0xdc,
    0x03, 0x13, 0x2d, 0x01, 0x2e, 0xc3, 0xf5, 0x0c, 0xbc, 0x0f, 0xb8, 0x12, 0x30, 0x10, 0x04, 0x03, 0xb0, 0x26, 0x25,
    0x21, 0x50, 0x03, 0x52, 0x98, 0x2e, 0x4d, 0xb7, 0x10, 0x30, 0x21, 0x2e, 0xee, 0x00, 0x02, 0x30, 0x60, 0x7f, 0x25,
    0x2e, 0x79, 0x00, 0x60, 0x6f, 0x00, 0x90, 0x05, 0x2f, 0x00, 0x30, 0x21, 0x2e, 0xea, 0x00, 0x15, 0x50, 0x21, 0x2e,
    0x64, 0xf5, 0x15, 0x52, 0x23, 0x2e, 0x60, 0xf5, 0x02, 0x32, 0x50, 0x6f, 0x00, 0x90, 0x02, 0x2f, 0x03, 0x30, 0x27,
    0x2e, 0x78, 0x00, 0x07, 0x2e, 0x60, 0xf5, 0x1a, 0x09, 0x00, 0x91, 0xa3, 0x2f, 0x19, 0x09, 0x00, 0x91, 0xa0, 0x2f,
    0x90, 0x6f, 0xa2, 0x6f, 0xb1, 0x6f, 0xc3, 0x6f, 0xd4, 0x6f, 0xe5, 0x6f, 0x7b, 0x6f, 0xf6, 0x6f, 0x87, 0x6f, 0x40,
    0x5f, 0xc8, 0x2e, 0xc0, 0x50, 0xe7, 0x7f, 0xf6, 0x7f, 0x26, 0x30, 0x0f, 0x2e, 0x61, 0xf5, 0x2f, 0x2e, 0x7c, 0x00,
    0x0f, 0x2e, 0x7c, 0x00, 0xbe, 0x09, 0xa2, 0x7f, 0x80, 0x7f, 0x80, 0xb3, 0xd5, 0x7f, 0xc4, 0x7f, 0xb3, 0x7f, 0x91,
    0x7f, 0x7b, 0x7f, 0x0b, 0x2f, 0x23, 0x50, 0x1a, 0x25, 0x12, 0x40, 0x42, 0x7f, 0x74, 0x82, 0x12, 0x40, 0x52, 0x7f,
    0x00, 0x2e, 0x00, 0x40, 0x60, 0x7f, 0x98, 0x2e, 0x6a, 0xd6, 0x81, 0x30, 0x01, 0x2e, 0x7c, 0x00, 0x01, 0x08, 0x00,
    0xb2, 0x42, 0x2f, 0x03, 0x2e, 0x89, 0x00, 0x01, 0x2e, 0x89, 0x00, 0x97, 0xbc, 0x06, 0xbc, 0x9f, 0xb8, 0x0f, 0xb8,
    0x00, 0x90, 0x23, 0x2e, 0xd8, 0x00, 0x10, 0x30, 0x01, 0x30, 0x2a, 0x2f, 0x03, 0x2e, 0xd4, 0x00, 0x44, 0xb2, 0x05,
    0x2f, 0x47, 0xb2, 0x00, 0x30, 0x2d, 0x2f, 0x21, 0x2e, 0x7c, 0x00, 0x2b, 0x2d, 0x03, 0x2e, 0xfd, 0xf5, 0x9e, 0xbc,
    0x9f, 0xb8, 0x40, 0x90, 0x14, 0x2f, 0x03, 0x2e, 0xfc, 0xf5, 0x99, 0xbc, 0x9f, 0xb8, 0x40, 0x90, 0x0e, 0x2f, 0x03,
    0x2e, 0x49, 0xf1, 0x25, 0x54, 0x4a, 0x08, 0x40, 0x90, 0x08, 0x2f, 0x98, 0x2e, 0x35, 0xb7, 0x00, 0xb2, 0x10, 0x30,
    0x03, 0x2f, 0x50, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0x10, 0x2d, 0x98, 0x2e, 0xaf, 0xb7, 0x00, 0x30, 0x21, 0x2e, 0x7c,
    0x00, 0x0a, 0x2d, 0x05, 0x2e, 0x69, 0xf7, 0x2d, 0xbd, 0x2f, 0xb9, 0x80, 0xb2, 0x01, 0x2f, 0x21, 0x2e, 0x7d, 0x00,
    0x23, 0x2e, 0x7c, 0x00, 0xe0, 0x31, 0x21, 0x2e, 0x61, 0xf5, 0xf6, 0x6f, 0xe7, 0x6f, 0x80, 0x6f, 0xa2, 0x6f, 0xb3,
    0x6f, 0xc4, 0x6f, 0xd5, 0x6f, 0x7b, 0x6f, 0x91, 0x6f, 0x40, 0x5f, 0xc8, 0x2e, 0x60, 0x51, 0x0a, 0x25, 0x36, 0x88,
    0xf4, 0x7f, 0xeb, 0x7f, 0x00, 0x32, 0x31, 0x52, 0x32, 0x30, 0x13, 0x30, 0x98, 0x2e, 0x15, 0xcb, 0x0a, 0x25, 0x33,
    0x84, 0xd2, 0x7f, 0x43, 0x30, 0x05, 0x50, 0x2d, 0x52, 0x98, 0x2e, 0x95, 0xc1, 0xd2, 0x6f, 0x27, 0x52, 0x98, 0x2e,
    0xd7, 0xc7, 0x2a, 0x25, 0xb0, 0x86, 0xc0, 0x7f, 0xd3, 0x7f, 0xaf, 0x84, 0x29, 0x50, 0xf1, 0x6f, 0x98, 0x2e, 0x4d,
    0xc8, 0x2a, 0x25, 0xae, 0x8a, 0xaa, 0x88, 0xf2, 0x6e, 0x2b, 0x50, 0xc1, 0x6f, 0xd3, 0x6f, 0xf4, 0x7f, 0x98, 0x2e,
    0xb6, 0xc8, 0xe0, 0x6e, 0x00, 0xb2, 0x32, 0x2f, 0x33, 0x54, 0x83, 0x86, 0xf1, 0x6f, 0xc3, 0x7f, 0x04, 0x30, 0x30,
    0x30, 0xf4, 0x7f, 0xd0, 0x7f, 0xb2, 0x7f, 0xe3, 0x30, 0xc5, 0x6f, 0x56, 0x40, 0x45, 0x41, 0x28, 0x08, 0x03, 0x14,
    0x0e, 0xb4, 0x08, 0xbc, 0x82, 0x40, 0x10, 0x0a, 0x2f, 0x54, 0x26, 0x05, 0x91, 0x7f, 0x44, 0x28, 0xa3, 0x7f, 0x98,
    0x2e, 0xd9, 0xc0, 0x08, 0xb9, 0x33, 0x30, 0x53, 0x09, 0xc1, 0x6f, 0xd3, 0x6f, 0xf4, 0x6f, 0x83, 0x17, 0x47, 0x40,
    0x6c, 0x15, 0xb2, 0x6f, 0xbe, 0x09, 0x75, 0x0b, 0x90, 0x42, 0x45, 0x42, 0x51, 0x0e, 0x32, 0xbc, 0x02, 0x89, 0xa1,
    0x6f, 0x7e, 0x86, 0xf4, 0x7f, 0xd0, 0x7f, 0xb2, 0x7f, 0x04, 0x30, 0x91, 0x6f, 0xd6, 0x2f, 0xeb, 0x6f, 0xa0, 0x5e,
    0xb8, 0x2e, 0x03, 0x2e, 0x97, 0x00, 0x1b, 0xbc, 0x60, 0x50, 0x9f, 0xbc, 0x0c, 0xb8, 0xf0, 0x7f, 0x40, 0xb2, 0xeb,
    0x7f, 0x2b, 0x2f, 0x03, 0x2e, 0x7f, 0x00, 0x41, 0x40, 0x01, 0x2e, 0xc8, 0x00, 0x01, 0x1a, 0x11, 0x2f, 0x37, 0x58,
    0x23, 0x2e, 0xc8, 0x00, 0x10, 0x41, 0xa0, 0x7f, 0x38, 0x81, 0x01, 0x41, 0xd0, 0x7f, 0xb1, 0x7f, 0x98, 0x2e, 0x64,
    0xcf, 0xd0, 0x6f, 0x07, 0x80, 0xa1, 0x6f, 0x11, 0x42, 0x00, 0x2e, 0xb1, 0x6f, 0x01, 0x42, 0x11, 0x30, 0x01, 0x2e,
    0xfc, 0x00, 0x00, 0xa8, 0x03, 0x30, 0xcb, 0x22, 0x4a, 0x25, 0x01, 0x2e, 0x7f, 0x00, 0x3c, 0x89, 0x35, 0x52, 0x05,
    0x54, 0x98, 0x2e, 0xc4, 0xce, 0xc1, 0x6f, 0xf0, 0x6f, 0x98, 0x2e, 0x95, 0xcf, 0x04, 0x2d, 0x01, 0x30, 0xf0, 0x6f,
    0x98, 0x2e, 0x95, 0xcf, 0xeb, 0x6f, 0xa0, 0x5f, 0xb8, 0x2e, 0x03, 0x2e, 0xb3, 0x00, 0x02, 0x32, 0xf0, 0x30, 0x03,
    0x31, 0x30, 0x50, 0x8a, 0x08, 0x08, 0x08, 0xcb, 0x08, 0xe0, 0x7f, 0x80, 0xb2, 0xf3, 0x7f, 0xdb, 0x7f, 0x25, 0x2f,
    0x03, 0x2e, 0xca, 0x00, 0x41, 0x90, 0x04, 0x2f, 0x01, 0x30, 0x23, 0x2e, 0xca, 0x00, 0x98, 0x2e, 0x3f, 0x03, 0xc0,
    0xb2, 0x05, 0x2f, 0x03, 0x2e, 0xda, 0x00, 0x00, 0x30, 0x41, 0x04, 0x23, 0x2e, 0xda, 0x00, 0x98, 0x2e, 0x92, 0xb2,
    0x10, 0x25, 0xf0, 0x6f, 0x00, 0xb2, 0x05, 0x2f, 0x01, 0x2e, 0xda, 0x00, 0x02, 0x30, 0x10, 0x04, 0x21, 0x2e, 0xda,
    0x00, 0x40, 0xb2, 0x01, 0x2f, 0x23, 0x2e, 0xc8, 0x01, 0xdb, 0x6f, 0xe0, 0x6f, 0xd0, 0x5f, 0x80, 0x2e, 0x95, 0xcf,
    0x01, 0x30, 0xe0, 0x6f, 0x98, 0x2e, 0x95, 0xcf, 0x11, 0x30, 0x23, 0x2e, 0xca, 0x00, 0xdb, 0x6f, 0xd0, 0x5f, 0xb8,
    0x2e, 0xd0, 0x50, 0x0a, 0x25, 0x33, 0x84, 0x55, 0x50, 0xd2, 0x7f, 0xe2, 0x7f, 0x03, 0x8c, 0xc0, 0x7f, 0xbb, 0x7f,
    0x00, 0x30, 0x05, 0x5a, 0x39, 0x54, 0x51, 0x41, 0xa5, 0x7f, 0x96, 0x7f, 0x80, 0x7f, 0x98, 0x2e, 0xd9, 0xc0, 0x05,
    0x30, 0xf5, 0x7f, 0x20, 0x25, 0x91, 0x6f, 0x3b, 0x58, 0x3d, 0x5c, 0x3b, 0x56, 0x98, 0x2e, 0x67, 0xcc, 0xc1, 0x6f,
    0xd5, 0x6f, 0x52, 0x40, 0x50, 0x43, 0xc1, 0x7f, 0xd5, 0x7f, 0x10, 0x25, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0x98,
    0x2e, 0x74, 0xc0, 0x86, 0x6f, 0x30, 0x28, 0x92, 0x6f, 0x82, 0x8c, 0xa5, 0x6f, 0x6f, 0x52, 0x69, 0x0e, 0x39, 0x54,
    0xdb, 0x2f, 0x19, 0xa0, 0x15, 0x30, 0x03, 0x2f, 0x00, 0x30, 0x21, 0x2e, 0x81, 0x01, 0x0a, 0x2d, 0x01, 0x2e, 0x81,
    0x01, 0x05, 0x28, 0x42, 0x36, 0x21, 0x2e, 0x81, 0x01, 0x02, 0x0e, 0x01, 0x2f, 0x98, 0x2e, 0xf3, 0x03, 0x57, 0x50,
    0x12, 0x30, 0x01, 0x40, 0x98, 0x2e, 0xfe, 0xc9, 0x51, 0x6f, 0x0b, 0x5c, 0x8e, 0x0e, 0x3b, 0x6f, 0x57, 0x58, 0x02,
    0x30, 0x21, 0x2e, 0x95, 0x01, 0x45, 0x6f, 0x2a, 0x8d, 0xd2, 0x7f, 0xcb, 0x7f, 0x13, 0x2f, 0x02, 0x30, 0x3f, 0x50,
    0xd2, 0x7f, 0xa8, 0x0e, 0x0e, 0x2f, 0xc0, 0x6f, 0x53, 0x54, 0x02, 0x00, 0x51, 0x54, 0x42, 0x0e, 0x10, 0x30, 0x59,
    0x52, 0x02, 0x30, 0x01, 0x2f, 0x00, 0x2e, 0x03, 0x2d, 0x50, 0x42, 0x42, 0x42, 0x12, 0x30, 0xd2, 0x7f, 0x80, 0xb2,
    0x03, 0x2f, 0x00, 0x30, 0x21, 0x2e, 0x80, 0x01, 0x12, 0x2d, 0x01, 0x2e, 0xc9, 0x00, 0x02, 0x80, 0x05, 0x2e, 0x80,
    0x01, 0x11, 0x30, 0x91, 0x28, 0x00, 0x40, 0x25, 0x2e, 0x80, 0x01, 0x10, 0x0e, 0x05, 0x2f, 0x01, 0x2e, 0x7f, 0x01,
    0x01, 0x90, 0x01, 0x2f, 0x98, 0x2e, 0xf3, 0x03, 0x00, 0x2e, 0xa0, 0x41, 0x01, 0x90, 0xa6, 0x7f, 0x90, 0x2e, 0xe3,
    0xb4, 0x01, 0x2e, 0x95, 0x01, 0x00, 0xa8, 0x90, 0x2e, 0xe3, 0xb4, 0x5b, 0x54, 0x95, 0x80, 0x82, 0x40, 0x80, 0xb2,
    0x02, 0x40, 0x2d, 0x8c, 0x3f, 0x52, 0x96, 0x7f, 0x90, 0x2e, 0xc2, 0xb3, 0x29, 0x0e, 0x76, 0x2f, 0x01, 0x2e, 0xc9,
    0x00, 0x00, 0x40, 0x81, 0x28, 0x45, 0x52, 0xb3, 0x30, 0x98, 0x2e, 0x0f, 0xca, 0x5d, 0x54, 0x80, 0x7f, 0x00, 0x2e,
    0xa1, 0x40, 0x72, 0x7f, 0x82, 0x80, 0x82, 0x40, 0x60, 0x7f, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0x98, 0x2e, 0x74,
    0xc0, 0x62, 0x6f, 0x05, 0x30, 0x87, 0x40, 0xc0, 0x91, 0x04, 0x30, 0x05, 0x2f, 0x05, 0x2e, 0x83, 0x01, 0x80, 0xb2,
    0x14, 0x30, 0x00, 0x2f, 0x04, 0x30, 0x05, 0x2e, 0xc9, 0x00, 0x73, 0x6f, 0x81, 0x40, 0xe2, 0x40, 0x69, 0x04, 0x11,
    0x0f, 0xe1, 0x40, 0x16, 0x30, 0xfe, 0x29, 0xcb, 0x40, 0x02, 0x2f, 0x83, 0x6f, 0x83, 0x0f, 0x22, 0x2f, 0x47, 0x56,
    0x13, 0x0f, 0x12, 0x30, 0x77, 0x2f, 0x49, 0x54, 0x42, 0x0e, 0x12, 0x30, 0x73, 0x2f, 0x00, 0x91, 0x0a, 0x2f, 0x01,
    0x2e, 0x8b, 0x01, 0x19, 0xa8, 0x02, 0x30, 0x6c, 0x2f, 0x63, 0x50, 0x00, 0x2e, 0x17, 0x42, 0x05, 0x42, 0x68, 0x2c,
    0x12, 0x30, 0x0b, 0x25, 0x08, 0x0f, 0x50, 0x30, 0x02, 0x2f, 0x21, 0x2e, 0x83, 0x01, 0x03, 0x2d, 0x40, 0x30, 0x21,
    0x2e, 0x83, 0x01, 0x2b, 0x2e, 0x85, 0x01, 0x5a, 0x2c, 0x12, 0x30, 0x00, 0x91, 0x2b, 0x25, 0x04, 0x2f, 0x63, 0x50,
    0x02, 0x30, 0x17, 0x42, 0x17, 0x2c, 0x02, 0x42, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0x98, 0x2e, 0x74, 0xc0, 0x05,
    0x2e, 0xc9, 0x00, 0x81, 0x84, 0x5b, 0x30, 0x82, 0x40, 0x37, 0x2e, 0x83, 0x01, 0x02, 0x0e, 0x07, 0x2f, 0x5f, 0x52,
    0x40, 0x30, 0x62, 0x40, 0x41, 0x40, 0x91, 0x0e, 0x01, 0x2f, 0x21, 0x2e, 0x83, 0x01, 0x05, 0x30, 0x2b, 0x2e, 0x85,
    0x01, 0x12, 0x30, 0x36, 0x2c, 0x16, 0x30, 0x15, 0x25, 0x81, 0x7f, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0x98, 0x2e,
    0x74, 0xc0, 0x19, 0xa2, 0x16, 0x30, 0x15, 0x2f, 0x05, 0x2e, 0x97, 0x01, 0x80, 0x6f, 0x82, 0x0e, 0x05, 0x2f, 0x01,
    0x2e, 0x86, 0x01, 0x06, 0x28, 0x21, 0x2e, 0x86, 0x01, 0x0b, 0x2d, 0x03, 0x2e, 0x87, 0x01, 0x5f, 0x54, 0x4e, 0x28,
    0x91, 0x42, 0x00, 0x2e, 0x82, 0x40, 0x90, 0x0e, 0x01, 0x2f, 0x21, 0x2e, 0x88, 0x01, 0x02, 0x30, 0x13, 0x2c, 0x05,
    0x30, 0xc0, 0x6f, 0x08, 0x1c, 0xa8, 0x0f, 0x16, 0x30, 0x05, 0x30, 0x5b, 0x50, 0x09, 0x2f, 0x02, 0x80, 0x2d, 0x2e,
    0x82, 0x01, 0x05, 0x42, 0x05, 0x80, 0x00, 0x2e, 0x02, 0x42, 0x3e, 0x80, 0x00, 0x2e, 0x06, 0x42, 0x02, 0x30, 0x90,
    0x6f, 0x3e, 0x88, 0x01, 0x40, 0x04, 0x41, 0x4c, 0x28, 0x01, 0x42, 0x07, 0x80, 0x10, 0x25, 0x24, 0x40, 0x00, 0x40,
    0x00, 0xa8, 0xf5, 0x22, 0x23, 0x29, 0x44, 0x42, 0x7a, 0x82, 0x7e, 0x88, 0x43, 0x40, 0x04, 0x41, 0x00, 0xab, 0xf5,
    0x23, 0xdf, 0x28, 0x43, 0x42, 0xd9, 0xa0, 0x14, 0x2f, 0x00, 0x90, 0x02, 0x2f, 0xd2, 0x6f, 0x81, 0xb2, 0x05, 0x2f,
    0x63, 0x54, 0x06, 0x28, 0x90, 0x42, 0x85, 0x42, 0x09, 0x2c, 0x02, 0x30, 0x5b, 0x50, 0x03, 0x80, 0x29, 0x2e, 0x7e,
    0x01, 0x2b, 0x2e, 0x82, 0x01, 0x05, 0x42, 0x12, 0x30, 0x2b, 0x2e, 0x83, 0x01, 0x45, 0x82, 0x00, 0x2e, 0x40, 0x40,
    0x7a, 0x82, 0x02, 0xa0, 0x08, 0x2f, 0x63, 0x50, 0x3b, 0x30, 0x15, 0x42, 0x05, 0x42, 0x37, 0x80, 0x37, 0x2e, 0x7e,
    0x01, 0x05, 0x42, 0x12, 0x30, 0x01, 0x2e, 0xc9, 0x00, 0x02, 0x8c, 0x40, 0x40, 0x84, 0x41, 0x7a, 0x8c, 0x04, 0x0f,
    0x03, 0x2f, 0x01, 0x2e, 0x8b, 0x01, 0x19, 0xa4, 0x04, 0x2f, 0x2b, 0x2e, 0x82, 0x01, 0x98, 0x2e, 0xf3, 0x03, 0x12,
    0x30, 0x81, 0x90, 0x61, 0x52, 0x08, 0x2f, 0x65, 0x42, 0x65, 0x42, 0x43, 0x80, 0x39, 0x84, 0x82, 0x88, 0x05, 0x42,
    0x45, 0x42, 0x85, 0x42, 0x05, 0x43, 0x00, 0x2e, 0x80, 0x41, 0x00, 0x90, 0x90, 0x2e, 0xe1, 0xb4, 0x65, 0x54, 0xc1,
    0x6f, 0x80, 0x40, 0x00, 0xb2, 0x43, 0x58, 0x69, 0x50, 0x44, 0x2f, 0x55, 0x5c, 0xb7, 0x87, 0x8c, 0x0f, 0x0d, 0x2e,
    0x96, 0x01, 0xc4, 0x40, 0x36, 0x2f, 0x41, 0x56, 0x8b, 0x0e, 0x2a, 0x2f, 0x0b, 0x52, 0xa1, 0x0e, 0x0a, 0x2f, 0x05,
    0x2e, 0x8f, 0x01, 0x14, 0x25, 0x98, 0x2e, 0xfe, 0xc9, 0x4b, 0x54, 0x02, 0x0f, 0x69, 0x50, 0x05, 0x30, 0x65, 0x54,
    0x15, 0x2f, 0x03, 0x2e, 0x8e, 0x01, 0x4d, 0x5c, 0x8e, 0x0f, 0x3a, 0x2f, 0x05, 0x2e, 0x8f, 0x01, 0x98, 0x2e, 0xfe,
    0xc9, 0x4f, 0x54, 0x82, 0x0f, 0x05, 0x30, 0x69, 0x50, 0x65, 0x54, 0x30, 0x2f, 0x6d, 0x52, 0x15, 0x30, 0x42, 0x8c,
    0x45, 0x42, 0x04, 0x30, 0x2b, 0x2c, 0x84, 0x43, 0x6b, 0x52, 0x42, 0x8c, 0x00, 0x2e, 0x85, 0x43, 0x15, 0x30, 0x24,
    0x2c, 0x45, 0x42, 0x8e, 0x0f, 0x20, 0x2f, 0x0d, 0x2e, 0x8e, 0x01, 0xb1, 0x0e, 0x1c, 0x2f, 0x23, 0x2e, 0x8e, 0x01,
    0x1a, 0x2d, 0x0e, 0x0e, 0x17, 0x2f, 0xa1, 0x0f, 0x15, 0x2f, 0x23, 0x2e, 0x8d, 0x01, 0x13, 0x2d, 0x98, 0x2e, 0x74,
    0xc0, 0x43, 0x54, 0xc2, 0x0e, 0x0a, 0x2f, 0x65, 0x50, 0x04, 0x80, 0x0b, 0x30, 0x06, 0x82, 0x0b, 0x42, 0x79, 0x80,
    0x41, 0x40, 0x12, 0x30, 0x25, 0x2e, 0x8c, 0x01, 0x01, 0x42, 0x05, 0x30, 0x69, 0x50, 0x65, 0x54, 0x84, 0x82, 0x43,
    0x84, 0xbe, 0x8c, 0x84, 0x40, 0x86, 0x41, 0x26, 0x29, 0x94, 0x42, 0xbe, 0x8e, 0xd5, 0x7f, 0x19, 0xa1, 0x43, 0x40,
    0x0b, 0x2e, 0x8c, 0x01, 0x84, 0x40, 0xc7, 0x41, 0x5d, 0x29, 0x27, 0x29, 0x45, 0x42, 0x84, 0x42, 0xc2, 0x7f, 0x01,
    0x2f, 0xc0, 0xb3, 0x1d, 0x2f, 0x05, 0x2e, 0x94, 0x01, 0x99, 0xa0, 0x01, 0x2f, 0x80, 0xb3, 0x13, 0x2f, 0x80, 0xb3,
    0x18, 0x2f, 0xc0, 0xb3, 0x16, 0x2f, 0x12, 0x40, 0x01, 0x40, 0x92, 0x7f, 0x98, 0x2e, 0x74, 0xc0, 0x92, 0x6f, 0x10,
    0x0f, 0x20, 0x30, 0x03, 0x2f, 0x10, 0x30, 0x21, 0x2e, 0x7e, 0x01, 0x0a, 0x2d, 0x21, 0x2e, 0x7e, 0x01, 0x07, 0x2d,
    0x20, 0x30, 0x21, 0x2e, 0x7e, 0x01, 0x03, 0x2d, 0x10, 0x30, 0x21, 0x2e, 0x7e, 0x01, 0xc2, 0x6f, 0x01, 0x2e, 0xc9,
    0x00, 0xbc, 0x84, 0x02, 0x80, 0x82, 0x40, 0x00, 0x40, 0x90, 0x0e, 0xd5, 0x6f, 0x02, 0x2f, 0x15, 0x30, 0x98, 0x2e,
    0xf3, 0x03, 0x41, 0x91, 0x05, 0x30, 0x07, 0x2f, 0x67, 0x50, 0x3d, 0x80, 0x2b, 0x2e, 0x8f, 0x01, 0x05, 0x42, 0x04,
    0x80, 0x00, 0x2e, 0x05, 0x42, 0x02, 0x2c, 0x00, 0x30, 0x00, 0x30, 0xa2, 0x6f, 0x98, 0x8a, 0x86, 0x40, 0x80, 0xa7,
    0x05, 0x2f, 0x98, 0x2e, 0xf3, 0x03, 0xc0, 0x30, 0x21, 0x2e, 0x95, 0x01, 0x06, 0x25, 0x1a, 0x25, 0xe2, 0x6f, 0x76,
    0x82, 0x96, 0x40, 0x56, 0x43, 0x51, 0x0e, 0xfb, 0x2f, 0xbb, 0x6f, 0x30, 0x5f, 0xb8, 0x2e, 0x01, 0x2e, 0xb8, 0x00,
    0x01, 0x31, 0x41, 0x08, 0x40, 0xb2, 0x20, 0x50, 0xf2, 0x30, 0x02, 0x08, 0xfb, 0x7f, 0x01, 0x30, 0x10, 0x2f, 0x05,
    0x2e, 0xcc, 0x00, 0x81, 0x90, 0xe0, 0x7f, 0x03, 0x2f, 0x23, 0x2e, 0xcc, 0x00, 0x98, 0x2e, 0x55, 0xb6, 0x98, 0x2e,
    0x1d, 0xb5, 0x10, 0x25, 0xfb, 0x6f, 0xe0, 0x6f, 0xe0, 0x5f, 0x80, 0x2e, 0x95, 0xcf, 0x98, 0x2e, 0x95, 0xcf, 0x10,
    0x30, 0x21, 0x2e, 0xcc, 0x00, 0xfb, 0x6f, 0xe0, 0x5f, 0xb8, 0x2e, 0x00, 0x51, 0x05, 0x58, 0xeb, 0x7f, 0x2a, 0x25,
    0x89, 0x52, 0x6f, 0x5a, 0x89, 0x50, 0x13, 0x41, 0x06, 0x40, 0xb3, 0x01, 0x16, 0x42, 0xcb, 0x16, 0x06, 0x40, 0xf3,
    0x02, 0x13, 0x42, 0x65, 0x0e, 0xf5, 0x2f, 0x05, 0x40, 0x14, 0x30, 0x2c, 0x29, 0x04, 0x42, 0x08, 0xa1, 0x00, 0x30,
    0x90, 0x2e, 0x52, 0xb6, 0xb3, 0x88, 0xb0, 0x8a, 0xb6, 0x84, 0xa4, 0x7f, 0xc4, 0x7f, 0xb5, 0x7f, 0xd5, 0x7f, 0x92,
    0x7f, 0x73, 0x30, 0x04, 0x30, 0x55, 0x40, 0x42, 0x40, 0x8a, 0x17, 0xf3, 0x08, 0x6b, 0x01, 0x90, 0x02, 0x53, 0xb8,
    0x4b, 0x82, 0xad, 0xbe, 0x71, 0x7f, 0x45, 0x0a, 0x09, 0x54, 0x84, 0x7f, 0x98, 0x2e, 0xd9, 0xc0, 0xa3, 0x6f, 0x7b,
    0x54, 0xd0, 0x42, 0xa3, 0x7f, 0xf2, 0x7f, 0x60, 0x7f, 0x20, 0x25, 0x71, 0x6f, 0x75, 0x5a, 0x77, 0x58, 0x79, 0x5c,
    0x75, 0x56, 0x98, 0x2e, 0x67, 0xcc, 0xb1, 0x6f, 0x62, 0x6f, 0x50, 0x42, 0xb1, 0x7f, 0xb3, 0x30, 0x10, 0x25, 0x98,
    0x2e, 0x0f, 0xca, 0x84, 0x6f, 0x20, 0x29, 0x71, 0x6f, 0x92, 0x6f, 0xa5, 0x6f, 0x76, 0x82, 0x6a, 0x0e, 0x73, 0x30,
    0x00, 0x30, 0xd0, 0x2f, 0xd2, 0x6f, 0xd1, 0x7f, 0xb4, 0x7f, 0x98, 0x2e, 0x2b, 0xb7, 0x15, 0xbd, 0x0b, 0xb8, 0x02,
    0x0a, 0xc2, 0x6f, 0xc0, 0x7f, 0x98, 0x2e, 0x2b, 0xb7, 0x15, 0xbd, 0x0b, 0xb8, 0x42, 0x0a, 0xc0, 0x6f, 0x08, 0x17,
    0x41, 0x18, 0x89, 0x16, 0xe1, 0x18, 0xd0, 0x18, 0xa1, 0x7f, 0x27, 0x25, 0x16, 0x25, 0x98, 0x2e, 0x79, 0xc0, 0x8b,
    0x54, 0x90, 0x7f, 0xb3, 0x30, 0x82, 0x40, 0x80, 0x90, 0x0d, 0x2f, 0x7d, 0x52, 0x92, 0x6f, 0x98, 0x2e, 0x0f, 0xca,
    0xb2, 0x6f, 0x90, 0x0e, 0x06, 0x2f, 0x8b, 0x50, 0x14, 0x30, 0x42, 0x6f, 0x51, 0x6f, 0x14, 0x42, 0x12, 0x42, 0x01,
    0x42, 0x00, 0x2e, 0x31, 0x6f, 0x98, 0x2e, 0x74, 0xc0, 0x41, 0x6f, 0x80, 0x7f, 0x98, 0x2e, 0x74, 0xc0, 0x82, 0x6f,
    0x10, 0x04, 0x43, 0x52, 0x01, 0x0f, 0x05, 0x2e, 0xcb, 0x00, 0x00, 0x30, 0x04, 0x30, 0x21, 0x2f, 0x51, 0x6f, 0x43,
    0x58, 0x8c, 0x0e, 0x04, 0x30, 0x1c, 0x2f, 0x85, 0x88, 0x41, 0x6f, 0x04, 0x41, 0x8c, 0x0f, 0x04, 0x30, 0x16, 0x2f,
    0x84, 0x88, 0x00, 0x2e, 0x04, 0x41, 0x04, 0x05, 0x8c, 0x0e, 0x04, 0x30, 0x0f, 0x2f, 0x82, 0x88, 0x31, 0x6f, 0x04,
    0x41, 0x04, 0x05, 0x8c, 0x0e, 0x04, 0x30, 0x08, 0x2f, 0x83, 0x88, 0x00, 0x2e, 0x04, 0x41, 0x8c, 0x0f, 0x04, 0x30,
    0x02, 0x2f, 0x21, 0x2e, 0xad, 0x01, 0x14, 0x30, 0x00, 0x91, 0x14, 0x2f, 0x03, 0x2e, 0xa1, 0x01, 0x41, 0x90, 0x0e,
    0x2f, 0x03, 0x2e, 0xad, 0x01, 0x14, 0x30, 0x4c, 0x28, 0x23, 0x2e, 0xad, 0x01, 0x46, 0xa0, 0x06, 0x2f, 0x81, 0x84,
    0x8d, 0x52, 0x48, 0x82, 0x82, 0x40, 0x21, 0x2e, 0xa1, 0x01, 0x42, 0x42, 0x5c, 0x2c, 0x02, 0x30, 0x05, 0x2e, 0xaa,
    0x01, 0x80, 0xb2, 0x02, 0x30, 0x55, 0x2f, 0x03, 0x2e, 0xa9, 0x01, 0x92, 0x6f, 0xb3, 0x30, 0x98, 0x2e, 0x0f, 0xca,
    0xb2, 0x6f, 0x90, 0x0f, 0x00, 0x30, 0x02, 0x30, 0x4a, 0x2f, 0xa2, 0x6f, 0x87, 0x52, 0x91, 0x00, 0x85, 0x52, 0x51,
    0x0e, 0x02, 0x2f, 0x00, 0x2e, 0x43, 0x2c, 0x02, 0x30, 0xc2, 0x6f, 0x7f, 0x52, 0x91, 0x0e, 0x02, 0x30, 0x3c, 0x2f,
    0x51, 0x6f, 0x81, 0x54, 0x98, 0x2e, 0xfe, 0xc9, 0x10, 0x25, 0xb3, 0x30, 0x21, 0x25, 0x98, 0x2e, 0x0f, 0xca, 0x32,
    0x6f, 0xc0, 0x7f, 0xb3, 0x30, 0x12, 0x25, 0x98, 0x2e, 0x0f, 0xca, 0x42, 0x6f, 0xb0, 0x7f, 0xb3, 0x30, 0x12, 0x25,
    0x98, 0x2e, 0x0f, 0xca, 0xb2, 0x6f, 0x90, 0x28, 0x83, 0x52, 0x98, 0x2e, 0xfe, 0xc9, 0xc2, 0x6f, 0x90, 0x0f, 0x00,
    0x30, 0x02, 0x30, 0x1d, 0x2f, 0x05, 0x2e, 0xa1, 0x01, 0x80, 0xb2, 0x12, 0x30, 0x0f, 0x2f, 0x42, 0x6f, 0x03, 0x2e,
    0xab, 0x01, 0x91, 0x0e, 0x02, 0x30, 0x12, 0x2f, 0x52, 0x6f, 0x03, 0x2e, 0xac, 0x01, 0x91, 0x0f, 0x02, 0x30, 0x0c,
    0x2f, 0x21, 0x2e, 0xaa, 0x01, 0x0a, 0x2c, 0x12, 0x30, 0x03, 0x2e, 0xcb, 0x00, 0x8d, 0x58, 0x08, 0x89, 0x41, 0x40,
    0x11, 0x43, 0x00, 0x43, 0x25, 0x2e, 0xa1, 0x01, 0xd4, 0x6f, 0x8f, 0x52, 0x00, 0x43, 0x3a, 0x89, 0x00, 0x2e, 0x10,
    0x43, 0x10, 0x43, 0x61, 0x0e, 0xfb, 0x2f, 0x03, 0x2e, 0xa0, 0x01, 0x11, 0x1a, 0x02, 0x2f, 0x02, 0x25, 0x21, 0x2e,
    0xa0, 0x01, 0xeb, 0x6f, 0x00, 0x5f, 0xb8, 0x2e, 0x91, 0x52, 0x10, 0x30, 0x02, 0x30, 0x95, 0x56, 0x52, 0x42, 0x4b,
    0x0e, 0xfc, 0x2f, 0x8d, 0x54, 0x88, 0x82, 0x93, 0x56, 0x80, 0x42, 0x53, 0x42, 0x40, 0x42, 0x42, 0x86, 0x83, 0x54,
    0xc0, 0x2e, 0xc2, 0x42, 0x00, 0x2e, 0xa3, 0x52, 0x00, 0x51, 0x52, 0x40, 0x47, 0x40, 0x1a, 0x25, 0x01, 0x2e, 0x97,
    0x00, 0x8f, 0xbe, 0x72, 0x86, 0xfb, 0x7f, 0x0b, 0x30, 0x7c, 0xbf, 0xa5, 0x50, 0x10, 0x08, 0xdf, 0xba, 0x70, 0x88,
    0xf8, 0xbf, 0xcb, 0x42, 0xd3, 0x7f, 0x6c, 0xbb, 0xfc, 0xbb, 0xc5, 0x0a, 0x90, 0x7f, 0x1b, 0x7f, 0x0b, 0x43, 0xc0,
    0xb2, 0xe5, 0x7f, 0xb7, 0x7f, 0xa6, 0x7f, 0xc4, 0x7f, 0x90, 0x2e, 0x1c, 0xb7, 0x07, 0x2e, 0xd2, 0x00, 0xc0, 0xb2,
    0x0b, 0x2f, 0x97, 0x52, 0x01, 0x2e, 0xcd, 0x00, 0x82, 0x7f, 0x98, 0x2e, 0xbb, 0xcc, 0x0b, 0x30, 0x37, 0x2e, 0xd2,
    0x00, 0x82, 0x6f, 0x90, 0x6f, 0x1a, 0x25, 0x00, 0xb2, 0x8b, 0x7f, 0x14, 0x2f, 0xa6, 0xbd, 0x25, 0xbd, 0xb6, 0xb9,
    0x2f, 0xb9, 0x80, 0xb2, 0xd4, 0xb0, 0x0c, 0x2f, 0x99, 0x54, 0x9b, 0x56, 0x0b, 0x30, 0x0b, 0x2e, 0xb1, 0x00, 0xa1,
    0x58, 0x9b, 0x42, 0xdb, 0x42, 0x6c, 0x09, 0x2b, 0x2e, 0xb1, 0x00, 0x8b, 0x42, 0xcb, 0x42, 0x86, 0x7f, 0x73, 0x84,
    0xa7, 0x56, 0xc3, 0x08, 0x39, 0x52, 0x05, 0x50, 0x72, 0x7f, 0x63, 0x7f, 0x98, 0x2e, 0xc2, 0xc0, 0xe1, 0x6f, 0x62,
    0x6f, 0xd1, 0x0a, 0x01, 0x2e, 0xcd, 0x00, 0xd5, 0x6f, 0xc4, 0x6f, 0x72, 0x6f, 0x97, 0x52, 0x9d, 0x5c, 0x98, 0x2e,
    0x06, 0xcd, 0x23, 0x6f, 0x90, 0x6f, 0x99, 0x52, 0xc0, 0xb2, 0x04, 0xbd, 0x54, 0x40, 0xaf, 0xb9, 0x45, 0x40, 0xe1,
    0x7f, 0x02, 0x30, 0x06, 0x2f, 0xc0, 0xb2, 0x02, 0x30, 0x03, 0x2f, 0x9b, 0x5c, 0x12, 0x30, 0x94, 0x43, 0x85, 0x43,
    0x03, 0xbf, 0x6f, 0xbb, 0x80, 0xb3, 0x20, 0x2f, 0x06, 0x6f, 0x26, 0x01, 0x16, 0x6f, 0x6e, 0x03, 0x45, 0x42, 0xc0,
    0x90, 0x29, 0x2e, 0xce, 0x00, 0x9b, 0x52, 0x14, 0x2f, 0x9b, 0x5c, 0x00, 0x2e, 0x93, 0x41, 0x86, 0x41, 0xe3, 0x04,
    0xae, 0x07, 0x80, 0xab, 0x04, 0x2f, 0x80, 0x91, 0x0a, 0x2f, 0x86, 0x6f, 0x73, 0x0f, 0x07, 0x2f, 0x83, 0x6f, 0xc0,
    0xb2, 0x04, 0x2f, 0x54, 0x42, 0x45, 0x42, 0x12, 0x30, 0x04, 0x2c, 0x11, 0x30, 0x02, 0x2c, 0x11, 0x30, 0x11, 0x30,
    0x02, 0xbc, 0x0f, 0xb8, 0xd2, 0x7f, 0x00, 0xb2, 0x0a, 0x2f, 0x01, 0x2e, 0xfc, 0x00, 0x05, 0x2e, 0xc7, 0x01, 0x10,
    0x1a, 0x02, 0x2f, 0x21, 0x2e, 0xc7, 0x01, 0x03, 0x2d, 0x02, 0x2c, 0x01, 0x30, 0x01, 0x30, 0xb0, 0x6f, 0x98, 0x2e,
    0x95, 0xcf, 0xd1, 0x6f, 0xa0, 0x6f, 0x98, 0x2e, 0x95, 0xcf, 0xe2, 0x6f, 0x9f, 0x52, 0x01, 0x2e, 0xce, 0x00, 0x82,
    0x40, 0x50, 0x42, 0x0c, 0x2c, 0x42, 0x42, 0x11, 0x30, 0x23, 0x2e, 0xd2, 0x00, 0x01, 0x30, 0xb0, 0x6f, 0x98, 0x2e,
    0x95, 0xcf, 0xa0, 0x6f, 0x01, 0x30, 0x98, 0x2e, 0x95, 0xcf, 0x00, 0x2e, 0xfb, 0x6f, 0x00, 0x5f, 0xb8, 0x2e, 0x83,
    0x86, 0x01, 0x30, 0x00, 0x30, 0x94, 0x40, 0x24, 0x18, 0x06, 0x00, 0x53, 0x0e, 0x4f, 0x02, 0xf9, 0x2f, 0xb8, 0x2e,
    0xa9, 0x52, 0x00, 0x2e, 0x60, 0x40, 0x41, 0x40, 0x0d, 0xbc, 0x98, 0xbc, 0xc0, 0x2e, 0x01, 0x0a, 0x0f, 0xb8, 0xab,
    0x52, 0x53, 0x3c, 0x52, 0x40, 0x40, 0x40, 0x4b, 0x00, 0x82, 0x16, 0x26, 0xb9, 0x01, 0xb8, 0x41, 0x40, 0x10, 0x08,
    0x97, 0xb8, 0x01, 0x08, 0xc0, 0x2e, 0x11, 0x30, 0x01, 0x08, 0x43, 0x86, 0x25, 0x40, 0x04, 0x40, 0xd8, 0xbe, 0x2c,
    0x0b, 0x22, 0x11, 0x54, 0x42, 0x03, 0x80, 0x4b, 0x0e, 0xf6, 0x2f, 0xb8, 0x2e, 0x9f, 0x50, 0x10, 0x50, 0xad, 0x52,
    0x05, 0x2e, 0xd3, 0x00, 0xfb, 0x7f, 0x00, 0x2e, 0x13, 0x40, 0x93, 0x42, 0x41, 0x0e, 0xfb, 0x2f, 0x98, 0x2e, 0xa5,
    0xb7, 0x98, 0x2e, 0x87, 0xcf, 0x01, 0x2e, 0xd9, 0x00, 0x00, 0xb2, 0xfb, 0x6f, 0x0b, 0x2f, 0x01, 0x2e, 0x69, 0xf7,
    0xb1, 0x3f, 0x01, 0x08, 0x01, 0x30, 0xf0, 0x5f, 0x23, 0x2e, 0xd9, 0x00, 0x21, 0x2e, 0x69, 0xf7, 0x80, 0x2e, 0x7a,
    0xb7, 0xf0, 0x5f, 0xb8, 0x2e, 0x01, 0x2e, 0xc0, 0xf8, 0x03, 0x2e, 0xfc, 0xf5, 0x15, 0x54, 0xaf, 0x56, 0x82, 0x08,
    0x0b, 0x2e, 0x69, 0xf7, 0xcb, 0x0a, 0xb1, 0x58, 0x80, 0x90, 0xdd, 0xbe, 0x4c, 0x08, 0x5f, 0xb9, 0x59, 0x22, 0x80,
    0x90, 0x07, 0x2f, 0x03, 0x34, 0xc3, 0x08, 0xf2, 0x3a, 0x0a, 0x08, 0x02, 0x35, 0xc0, 0x90, 0x4a, 0x0a, 0x48, 0x22,
    0xc0, 0x2e, 0x23, 0x2e, 0xfc, 0xf5, 0x10, 0x50, 0xfb, 0x7f, 0x98, 0x2e, 0x56, 0xc7, 0x98, 0x2e, 0x49, 0xc3, 0x10,
    0x30, 0xfb, 0x6f, 0xf0, 0x5f, 0x21, 0x2e, 0xcc, 0x00, 0x21, 0x2e, 0xca, 0x00, 0xb8, 0x2e, 0x03, 0x2e, 0xd3, 0x00,
    0x16, 0xb8, 0x02, 0x34, 0x4a, 0x0c, 0x21, 0x2e, 0x2d, 0xf5, 0xc0, 0x2e, 0x23, 0x2e, 0xd3, 0x00, 0x03, 0xbc, 0x21,
    0x2e, 0xd5, 0x00, 0x03, 0x2e, 0xd5, 0x00, 0x40, 0xb2, 0x10, 0x30, 0x21, 0x2e, 0x77, 0x00, 0x01, 0x30, 0x05, 0x2f,
    0x05, 0x2e, 0xd8, 0x00, 0x80, 0x90, 0x01, 0x2f, 0x23, 0x2e, 0x6f, 0xf5, 0xc0, 0x2e, 0x21, 0x2e, 0xd9, 0x00, 0x11,
    0x30, 0x81, 0x08, 0x01, 0x2e, 0x6a, 0xf7, 0x71, 0x3f, 0x23, 0xbd, 0x01, 0x08, 0x02, 0x0a, 0xc0, 0x2e, 0x21, 0x2e,
    0x6a, 0xf7, 0x30, 0x25, 0x00, 0x30, 0x21, 0x2e, 0x5a, 0xf5, 0x10, 0x50, 0x21, 0x2e, 0x7b, 0x00, 0x21, 0x2e, 0x7c,
    0x00, 0xfb, 0x7f, 0x98, 0x2e, 0xc3, 0xb7, 0x40, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0xfb, 0x6f, 0xf0, 0x5f, 0x03, 0x25,
    0x80, 0x2e, 0xaf, 0xb7, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x01, 0x2e, 0x5d, 0xf7, 0x08, 0xbc, 0x80, 0xac, 0x0e, 0xbb, 0x02, 0x2f,
    0x00, 0x30, 0x41, 0x04, 0x82, 0x06, 0xc0, 0xa4, 0x00, 0x30, 0x11, 0x2f, 0x40, 0xa9, 0x03, 0x2f, 0x40, 0x91, 0x0d,
    0x2f, 0x00, 0xa7, 0x0b, 0x2f, 0x80, 0xb3, 0xb3, 0x58, 0x02, 0x2f, 0x90, 0xa1, 0x26, 0x13, 0x20, 0x23, 0x80, 0x90,
    0x10, 0x30, 0x01, 0x2f, 0xcc, 0x0e, 0x00, 0x2f, 0x00, 0x30, 0xb8, 0x2e, 0xb5, 0x50, 0x18, 0x08, 0x08, 0xbc, 0x88,
    0xb6, 0x0d, 0x17, 0xc6, 0xbd, 0x56, 0xbc, 0xb7, 0x58, 0xda, 0xba, 0x04, 0x01, 0x1d, 0x0a, 0x10, 0x50, 0x05, 0x30,
    0x32, 0x25, 0x45, 0x03, 0xfb, 0x7f, 0xf6, 0x30, 0x21, 0x25, 0x98, 0x2e, 0x37, 0xca, 0x16, 0xb5, 0x9a, 0xbc, 0x06,
    0xb8, 0x80, 0xa8, 0x41, 0x0a, 0x0e, 0x2f, 0x80, 0x90, 0x02, 0x2f, 0x2d, 0x50, 0x48, 0x0f, 0x09, 0x2f, 0xbf, 0xa0,
    0x04, 0x2f, 0xbf, 0x90, 0x06, 0x2f, 0xb7, 0x54, 0xca, 0x0f, 0x03, 0x2f, 0x00, 0x2e, 0x02, 0x2c, 0xb7, 0x52, 0x2d,
    0x52, 0xf2, 0x33, 0x98, 0x2e, 0xd9, 0xc0, 0xfb, 0x6f, 0xf1, 0x37, 0xc0, 0x2e, 0x01, 0x08, 0xf0, 0x5f, 0xbf, 0x56,
    0xb9, 0x54, 0xd0, 0x40, 0xc4, 0x40, 0x0b, 0x2e, 0xfd, 0xf3, 0xbf, 0x52, 0x90, 0x42, 0x94, 0x42, 0x95, 0x42, 0x05,
    0x30, 0xc1, 0x50, 0x0f, 0x88, 0x06, 0x40, 0x04, 0x41, 0x96, 0x42, 0xc5, 0x42, 0x48, 0xbe, 0x73, 0x30, 0x0d, 0x2e,
    0xd8, 0x00, 0x4f, 0xba, 0x84, 0x42, 0x03, 0x42, 0x81, 0xb3, 0x02, 0x2f, 0x2b, 0x2e, 0x6f, 0xf5, 0x06, 0x2d, 0x05,
    0x2e, 0x77, 0xf7, 0xbd, 0x56, 0x93, 0x08, 0x25, 0x2e, 0x77, 0xf7, 0xbb, 0x54, 0x25, 0x2e, 0xc2, 0xf5, 0x07, 0x2e,
    0xfd, 0xf3, 0x42, 0x30, 0xb4, 0x33, 0xda, 0x0a, 0x4c, 0x00, 0x27, 0x2e, 0xfd, 0xf3, 0x43, 0x40, 0xd4, 0x3f, 0xdc,
    0x08, 0x43, 0x42, 0x00, 0x2e, 0x00, 0x2e, 0x43, 0x40, 0x24, 0x30, 0xdc, 0x0a, 0x43, 0x42, 0x04, 0x80, 0x03, 0x2e,
    0xfd, 0xf3, 0x4a, 0x0a, 0x23, 0x2e, 0xfd, 0xf3, 0x61, 0x34, 0xc0, 0x2e, 0x01, 0x42, 0x00, 0x2e, 0x60, 0x50, 0x1a,
    0x25, 0x7a, 0x86, 0xe0, 0x7f, 0xf3, 0x7f, 0x03, 0x25, 0xc3, 0x52, 0x41, 0x84, 0xdb, 0x7f, 0x33, 0x30, 0x98, 0x2e,
    0x16, 0xc2, 0x1a, 0x25, 0x7d, 0x82, 0xf0, 0x6f, 0xe2, 0x6f, 0x32, 0x25, 0x16, 0x40, 0x94, 0x40, 0x26, 0x01, 0x85,
    0x40, 0x8e, 0x17, 0xc4, 0x42, 0x6e, 0x03, 0x95, 0x42, 0x41, 0x0e, 0xf4, 0x2f, 0xdb, 0x6f, 0xa0, 0x5f, 0xb8, 0x2e,
    0xb0, 0x51, 0xfb, 0x7f, 0x98, 0x2e, 0xe8, 0x0d, 0x5a, 0x25, 0x98, 0x2e, 0x0f, 0x0e, 0xcb, 0x58, 0x32, 0x87, 0xc4,
    0x7f, 0x65, 0x89, 0x6b, 0x8d, 0xc5, 0x5a, 0x65, 0x7f, 0xe1, 0x7f, 0x83, 0x7f, 0xa6, 0x7f, 0x74, 0x7f, 0xd0, 0x7f,
    0xb6, 0x7f, 0x94, 0x7f, 0x17, 0x30, 0xc7, 0x52, 0xc9, 0x54, 0x51, 0x7f, 0x00, 0x2e, 0x85, 0x6f, 0x42, 0x7f, 0x00,
    0x2e, 0x51, 0x41, 0x45, 0x81, 0x42, 0x41, 0x13, 0x40, 0x3b, 0x8a, 0x00, 0x40, 0x4b, 0x04, 0xd0, 0x06, 0xc0, 0xac,
    0x85, 0x7f, 0x02, 0x2f, 0x02, 0x30, 0x51, 0x04, 0xd3, 0x06, 0x41, 0x84, 0x05, 0x30, 0x5d, 0x02, 0xc9, 0x16, 0xdf,
    0x08, 0xd3, 0x00, 0x8d, 0x02, 0xaf, 0xbc, 0xb1, 0xb9, 0x59, 0x0a, 0x65, 0x6f, 0x11, 0x43, 0xa1, 0xb4, 0x52, 0x41,
    0x53, 0x41, 0x01, 0x43, 0x34, 0x7f, 0x65, 0x7f, 0x26, 0x31, 0xe5, 0x6f, 0xd4, 0x6f, 0x98, 0x2e, 0x37, 0xca, 0x32,
    0x6f, 0x75, 0x6f, 0x83, 0x40, 0x42, 0x41, 0x23, 0x7f, 0x12, 0x7f, 0xf6, 0x30, 0x40, 0x25, 0x51, 0x25, 0x98, 0x2e,
    0x37, 0xca, 0x14, 0x6f, 0x20, 0x05, 0x70, 0x6f, 0x25, 0x6f, 0x69, 0x07, 0xa2, 0x6f, 0x31, 0x6f, 0x0b, 0x30, 0x04,
    0x42, 0x9b, 0x42, 0x8b, 0x42, 0x55, 0x42, 0x32, 0x7f, 0x40, 0xa9, 0xc3, 0x6f, 0x71, 0x7f, 0x02, 0x30, 0xd0, 0x40,
    0xc3, 0x7f, 0x03, 0x2f, 0x40, 0x91, 0x15, 0x2f, 0x00, 0xa7, 0x13, 0x2f, 0x00, 0xa4, 0x11, 0x2f, 0x84, 0xbd, 0x98,
    0x2e, 0x79, 0xca, 0x55, 0x6f, 0xb7, 0x54, 0x54, 0x41, 0x82, 0x00, 0xf3, 0x3f, 0x45, 0x41, 0xcb, 0x02, 0xf6, 0x30,
    0x98, 0x2e, 0x37, 0xca, 0x35, 0x6f, 0xa4, 0x6f, 0x41, 0x43, 0x03, 0x2c, 0x00, 0x43, 0xa4, 0x6f, 0x35, 0x6f, 0x17,
    0x30, 0x42, 0x6f, 0x51, 0x6f, 0x93, 0x40, 0x42, 0x82, 0x00, 0x41, 0xc3, 0x00, 0x03, 0x43, 0x51, 0x7f, 0x00, 0x2e,
    0x94, 0x40, 0x41, 0x41, 0x4c, 0x02, 0xc4, 0x6f, 0xd1, 0x56, 0x63, 0x0e, 0x74, 0x6f, 0x51, 0x43, 0xa5, 0x7f, 0x8a,
    0x2f, 0x09, 0x2e, 0xd8, 0x00, 0x01, 0xb3, 0x21, 0x2f, 0xcb, 0x58, 0x90, 0x6f, 0x13, 0x41, 0xb6, 0x6f, 0xe4, 0x7f,
    0x00, 0x2e, 0x91, 0x41, 0x14, 0x40, 0x92, 0x41, 0x15, 0x40, 0x17, 0x2e, 0x6f, 0xf5, 0xb6, 0x7f, 0xd0, 0x7f, 0xcb,
    0x7f, 0x98, 0x2e, 0x00, 0x0c, 0x07, 0x15, 0xc2, 0x6f, 0x14, 0x0b, 0x29, 0x2e, 0x6f, 0xf5, 0xc3, 0xa3, 0xc1, 0x8f,
    0xe4, 0x6f, 0xd0, 0x6f, 0xe6, 0x2f, 0x14, 0x30, 0x05, 0x2e, 0x6f, 0xf5, 0x14, 0x0b, 0x29, 0x2e, 0x6f, 0xf5, 0x18,
    0x2d, 0xcd, 0x56, 0x04, 0x32, 0xb5, 0x6f, 0x1c, 0x01, 0x51, 0x41, 0x52, 0x41, 0xc3, 0x40, 0xb5, 0x7f, 0xe4, 0x7f,
    0x98, 0x2e, 0x1f, 0x0c, 0xe4, 0x6f, 0x21, 0x87, 0x00, 0x43, 0x04, 0x32, 0xcf, 0x54, 0x5a, 0x0e, 0xef, 0x2f, 0x15,
    0x54, 0x09, 0x2e, 0x77, 0xf7, 0x22, 0x0b, 0x29, 0x2e, 0x77, 0xf7, 0xfb, 0x6f, 0x50, 0x5e, 0xb8, 0x2e, 0x10, 0x50,
    0x01, 0x2e, 0xd4, 0x00, 0x00, 0xb2, 0xfb, 0x7f, 0x51, 0x2f, 0x01, 0xb2, 0x48, 0x2f, 0x02, 0xb2, 0x42, 0x2f, 0x03,
    0x90, 0x56, 0x2f, 0xd7, 0x52, 0x79, 0x80, 0x42, 0x40, 0x81, 0x84, 0x00, 0x40, 0x42, 0x42, 0x98, 0x2e, 0x93, 0x0c,
    0xd9, 0x54, 0xd7, 0x50, 0xa1, 0x40, 0x98, 0xbd, 0x82, 0x40, 0x3e, 0x82, 0xda, 0x0a, 0x44, 0x40, 0x8b, 0x16, 0xe3,
    0x00, 0x53, 0x42, 0x00, 0x2e, 0x43, 0x40, 0x9a, 0x02, 0x52, 0x42, 0x00, 0x2e, 0x41, 0x40, 0x15, 0x54, 0x4a, 0x0e,
    0x3a, 0x2f, 0x3a, 0x82, 0x00, 0x30, 0x41, 0x40, 0x21, 0x2e, 0x85, 0x0f, 0x40, 0xb2, 0x0a, 0x2f, 0x98, 0x2e, 0xb1,
    0x0c, 0x98, 0x2e, 0x45, 0x0e, 0x98, 0x2e, 0x5b, 0x0e, 0xfb, 0x6f, 0xf0, 0x5f, 0x00, 0x30, 0x80, 0x2e, 0xce, 0xb7,
    0xdd, 0x52, 0xd3, 0x54, 0x42, 0x42, 0x4f, 0x84, 0x73, 0x30, 0xdb, 0x52, 0x83, 0x42, 0x1b, 0x30, 0x6b, 0x42, 0x23,
    0x30, 0x27, 0x2e, 0xd7, 0x00, 0x37, 0x2e, 0xd4, 0x00, 0x21, 0x2e, 0xd6, 0x00, 0x7a, 0x84, 0x17, 0x2c, 0x42, 0x42,
    0x30, 0x30, 0x21, 0x2e, 0xd4, 0x00, 0x12, 0x2d, 0x21, 0x30, 0x00, 0x30, 0x23, 0x2e, 0xd4, 0x00, 0x21, 0x2e, 0x7b,
    0xf7, 0x0b, 0x2d, 0x17, 0x30, 0x98, 0x2e, 0x51, 0x0c, 0xd5, 0x50, 0x0c, 0x82, 0x72, 0x30, 0x2f, 0x2e, 0xd4, 0x00,
    0x25, 0x2e, 0x7b, 0xf7, 0x40, 0x42, 0x00, 0x2e, 0xfb, 0x6f, 0xf0, 0x5f, 0xb8, 0x2e, 0x70, 0x50, 0x0a, 0x25, 0x39,
    0x86, 0xfb, 0x7f, 0xe1, 0x32, 0x62, 0x30, 0x98, 0x2e, 0xc2, 0xc4, 0xb5, 0x56, 0xa5, 0x6f, 0xab, 0x08, 0x91, 0x6f,
    0x4b, 0x08, 0xdf, 0x56, 0xc4, 0x6f, 0x23, 0x09, 0x4d, 0xba, 0x93, 0xbc, 0x8c, 0x0b, 0xd1, 0x6f, 0x0b, 0x09, 0xcb,
    0x52, 0xe1, 0x5e, 0x56, 0x42, 0xaf, 0x09, 0x4d, 0xba, 0x23, 0xbd, 0x94, 0x0a, 0xe5, 0x6f, 0x68, 0xbb, 0xeb, 0x08,
    0xbd, 0xb9, 0x63, 0xbe, 0xfb, 0x6f, 0x52, 0x42, 0xe3, 0x0a, 0xc0, 0x2e, 0x43, 0x42, 0x90, 0x5f, 0xd1, 0x50, 0x03,
    0x2e, 0x25, 0xf3, 0x13, 0x40, 0x00, 0x40, 0x9b, 0xbc, 0x9b, 0xb4, 0x08, 0xbd, 0xb8, 0xb9, 0x98, 0xbc, 0xda, 0x0a,
    0x08, 0xb6, 0x89, 0x16, 0xc0, 0x2e, 0x19, 0x00, 0x62, 0x02, 0x10, 0x50, 0xfb, 0x7f, 0x98, 0x2e, 0x81, 0x0d, 0x01,
    0x2e, 0xd4, 0x00, 0x31, 0x30, 0x08, 0x04, 0xfb, 0x6f, 0x01, 0x30, 0xf0, 0x5f, 0x23, 0x2e, 0xd6, 0x00, 0x21, 0x2e,
    0xd7, 0x00, 0xb8, 0x2e, 0x01, 0x2e, 0xd7, 0x00, 0x03, 0x2e, 0xd6, 0x00, 0x48, 0x0e, 0x01, 0x2f, 0x80, 0x2e, 0x1f,
    0x0e, 0xb8, 0x2e, 0xe3, 0x50, 0x21, 0x34, 0x01, 0x42, 0x82, 0x30, 0xc1, 0x32, 0x25, 0x2e, 0x62, 0xf5, 0x01, 0x00,
    0x22, 0x30, 0x01, 0x40, 0x4a, 0x0a, 0x01, 0x42, 0xb8, 0x2e, 0xe3, 0x54, 0xf0, 0x3b, 0x83, 0x40, 0xd8, 0x08, 0xe5,
    0x52, 0x83, 0x42, 0x00, 0x30, 0x83, 0x30, 0x50, 0x42, 0xc4, 0x32, 0x27, 0x2e, 0x64, 0xf5, 0x94, 0x00, 0x50, 0x42,
    0x40, 0x42, 0xd3, 0x3f, 0x84, 0x40, 0x7d, 0x82, 0xe3, 0x08, 0x40, 0x42, 0x83, 0x42, 0xb8, 0x2e, 0xdd, 0x52, 0x00,
    0x30, 0x40, 0x42, 0x7c, 0x86, 0xb9, 0x52, 0x09, 0x2e, 0x70, 0x0f, 0xbf, 0x54, 0xc4, 0x42, 0xd3, 0x86, 0x54, 0x40,
    0x55, 0x40, 0x94, 0x42, 0x85, 0x42, 0x21, 0x2e, 0xd7, 0x00, 0x42, 0x40, 0x25, 0x2e, 0xfd, 0xf3, 0xc0, 0x42, 0x7e,
    0x82, 0x05, 0x2e, 0x7d, 0x00, 0x80, 0xb2, 0x14, 0x2f, 0x05, 0x2e, 0x89, 0x00, 0x27, 0xbd, 0x2f, 0xb9, 0x80, 0x90,
    0x02, 0x2f, 0x21, 0x2e, 0x6f, 0xf5, 0x0c, 0x2d, 0x07, 0x2e, 0x71, 0x0f, 0x14, 0x30, 0x1c, 0x09, 0x05, 0x2e, 0x77,
    0xf7, 0xbd, 0x56, 0x47, 0xbe, 0x93, 0x08, 0x94, 0x0a, 0x25, 0x2e, 0x77, 0xf7, 0xe7, 0x54, 0x50, 0x42, 0x4a, 0x0e,
    0xfc, 0x2f, 0xb8, 0x2e, 0x50, 0x50, 0x02, 0x30, 0x43, 0x86, 0xe5, 0x50, 0xfb, 0x7f, 0xe3, 0x7f, 0xd2, 0x7f, 0xc0,
    0x7f, 0xb1, 0x7f, 0x00, 0x2e, 0x41, 0x40, 0x00, 0x40, 0x48, 0x04, 0x98, 0x2e, 0x74, 0xc0, 0x1e, 0xaa, 0xd3, 0x6f,
    0x14, 0x30, 0xb1, 0x6f, 0xe3, 0x22, 0xc0, 0x6f, 0x52, 0x40, 0xe4, 0x6f, 0x4c, 0x0e, 0x12, 0x42, 0xd3, 0x7f, 0xeb,
    0x2f, 0x03, 0x2e, 0x86, 0x0f, 0x40, 0x90, 0x11, 0x30, 0x03, 0x2f, 0x23, 0x2e, 0x86, 0x0f, 0x02, 0x2c, 0x00, 0x30,
    0xd0, 0x6f, 0xfb, 0x6f, 0xb0, 0x5f, 0xb8, 0x2e, 0x40, 0x50, 0xf1, 0x7f, 0x0a, 0x25, 0x3c, 0x86, 0xeb, 0x7f, 0x41,
    0x33, 0x22, 0x30, 0x98, 0x2e, 0xc2, 0xc4, 0xd3, 0x6f, 0xf4, 0x30, 0xdc, 0x09, 0x47, 0x58, 0xc2, 0x6f, 0x94, 0x09,
    0xeb, 0x58, 0x6a, 0xbb, 0xdc, 0x08, 0xb4, 0xb9, 0xb1, 0xbd, 0xe9, 0x5a, 0x95, 0x08, 0x21, 0xbd, 0xf6, 0xbf, 0x77,
    0x0b, 0x51, 0xbe, 0xf1, 0x6f, 0xeb, 0x6f, 0x52, 0x42, 0x54, 0x42, 0xc0, 0x2e, 0x43, 0x42, 0xc0, 0x5f, 0x50, 0x50,
    0xf5, 0x50, 0x31, 0x30, 0x11, 0x42, 0xfb, 0x7f, 0x7b, 0x30, 0x0b, 0x42, 0x11, 0x30, 0x02, 0x80, 0x23, 0x33, 0x01,
    0x42, 0x03, 0x00, 0x07, 0x2e, 0x80, 0x03, 0x05, 0x2e, 0xd3, 0x00, 0x23, 0x52, 0xe2, 0x7f, 0xd3, 0x7f, 0xc0, 0x7f,
    0x98, 0x2e, 0xb6, 0x0e, 0xd1, 0x6f, 0x08, 0x0a, 0x1a, 0x25, 0x7b, 0x86, 0xd0, 0x7f, 0x01, 0x33, 0x12, 0x30, 0x98,
    0x2e, 0xc2, 0xc4, 0xd1, 0x6f, 0x08, 0x0a, 0x00, 0xb2, 0x0d, 0x2f, 0xe3, 0x6f, 0x01, 0x2e, 0x80, 0x03, 0x51, 0x30,
    0xc7, 0x86, 0x23, 0x2e, 0x21, 0xf2, 0x08, 0xbc, 0xc0, 0x42, 0x98, 0x2e, 0xa5, 0xb7, 0x00, 0x2e, 0x00, 0x2e, 0xd0,
    0x2e, 0xb0, 0x6f, 0x0b, 0xb8, 0x03, 0x2e, 0x1b, 0x00, 0x08, 0x1a, 0xb0, 0x7f, 0x70, 0x30, 0x04, 0x2f, 0x21, 0x2e,
    0x21, 0xf2, 0x00, 0x2e, 0x00, 0x2e, 0xd0, 0x2e, 0x98, 0x2e, 0x6d, 0xc0, 0x98, 0x2e, 0x5d, 0xc0, 0xed, 0x50, 0x98,
    0x2e, 0x44, 0xcb, 0xef, 0x50, 0x98, 0x2e, 0x46, 0xc3, 0xf1, 0x50, 0x98, 0x2e, 0x53, 0xc7, 0x35, 0x50, 0x98, 0x2e,
    0x64, 0xcf, 0x10, 0x30, 0x98, 0x2e, 0xdc, 0x03, 0x20, 0x26, 0xc0, 0x6f, 0x02, 0x31, 0x12, 0x42, 0xab, 0x33, 0x0b,
    0x42, 0x37, 0x80, 0x01, 0x30, 0x01, 0x42, 0xf3, 0x37, 0xf7, 0x52, 0xfb, 0x50, 0x44, 0x40, 0xa2, 0x0a, 0x42, 0x42,
    0x8b, 0x31, 0x09, 0x2e, 0x5e, 0xf7, 0xf9, 0x54, 0xe3, 0x08, 0x83, 0x42, 0x1b, 0x42, 0x23, 0x33, 0x4b, 0x00, 0xbc,
    0x84, 0x0b, 0x40, 0x33, 0x30, 0x83, 0x42, 0x0b, 0x42, 0xe0, 0x7f, 0xd1, 0x7f, 0x98, 0x2e, 0x58, 0xb7, 0xd1, 0x6f,
    0x80, 0x30, 0x40, 0x42, 0x03, 0x30, 0xe0, 0x6f, 0xf3, 0x54, 0x04, 0x30, 0x00, 0x2e, 0x00, 0x2e, 0x01, 0x89, 0x62,
    0x0e, 0xfa, 0x2f, 0x43, 0x42, 0x11, 0x30, 0xfb, 0x6f, 0xc0, 0x2e, 0x01, 0x42, 0xb0, 0x5f, 0xc1, 0x4a, 0x00, 0x00,
    0x6d, 0x57, 0x00, 0x00, 0x77, 0x8e, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xd3, 0xff, 0xff, 0xff, 0xe5, 0xff, 0xff,
    0xff, 0xee, 0xe1, 0xff, 0xff, 0x7c, 0x13, 0x00, 0x00, 0x46, 0xe6, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
    0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00,
    0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
    0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80,
    0x2e, 0x00, 0xc1
};

// Function for sending things to UART1
static int uart1_printf(const char *str, va_list ap) {
    char *buf;
    vasprintf(&buf, str, ap);
    uart_write_bytes(UART_NUM_1, buf, strlen(buf));
    free(buf);
    return 0;
}

// Write message through UART_num with an \0 at the end
int serial_write(const char *msg, int len){

    char *send_with_end = (char *)malloc(sizeof(char) * (len + 1));
    memcpy(send_with_end, msg, len);
    send_with_end[len] = '\0';

    int result = uart_write_bytes(UART_NUM, send_with_end, len+1);

    free(send_with_end);

    vTaskDelay(pdMS_TO_TICKS(1000));  // Delay for 1 second
    return result;
}

int serial_read_timeout(char *buffer, int size, int timeout){
    int len = uart_read_bytes(UART_NUM, (uint8_t*)buffer, size, pdMS_TO_TICKS(timeout));
    return len;
}

// Read UART_num for input with timeout of 1 sec
int serial_read(char *buffer, int size){
    return serial_read_timeout(buffer, size, 1000);
}

// Setup of UART connections 0 and 1, and try to redirect logs to UART1 if asked
static void uart_setup() {
    uart_config_t uart_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
    };

    uart_param_config(UART_NUM_0, &uart_config);
    uart_param_config(UART_NUM_1, &uart_config);
    uart_driver_install(UART_NUM_0, BUF_SIZE * 2, 0, 0, NULL, 0);
    uart_driver_install(UART_NUM_1, BUF_SIZE * 2, 0, 0, NULL, 0);

    // Redirect ESP log to UART1
    if (REDIRECT_LOGS) {
        esp_log_set_vprintf(uart1_printf);
    }
}

esp_err_t i2c_init(void){
    int i2c_master_port = I2C_NUM_0;
    i2c_config_t conf;
    conf.mode = I2C_MODE_MASTER;
    conf.sda_io_num = I2C_MASTER_SDA_IO;
    conf.sda_pullup_en = GPIO_PULLUP_DISABLE;
    conf.scl_io_num = I2C_MASTER_SCL_IO;
    conf.scl_pullup_en = GPIO_PULLUP_DISABLE;
    conf.master.clk_speed = I2C_MASTER_FREQ_HZ;
    conf.clk_flags = I2C_SCLK_SRC_FLAG_FOR_NOMAL; // 0
    i2c_param_config(i2c_master_port, &conf);
    return i2c_driver_install(i2c_master_port, conf.mode, 0, 0, 0);
}

esp_err_t bmi_init(void){
    return i2c_init();
}

esp_err_t bme_init(void){
    return i2c_init();
}

esp_err_t bmi_read(i2c_port_t i2c_num, uint8_t *data_addres, uint8_t *data_rd , size_t size){
    if (size == 0) {
        return ESP_OK;
    }
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR_BMI << 1) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write(cmd, data_addres, size, ACK_CHECK_EN);
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR_BMI << 1) | READ_BIT, ACK_CHECK_EN);
    if (size > 1) {
        i2c_master_read(cmd, data_rd, size - 1, ACK_VAL);
    }
    i2c_master_read_byte(cmd, data_rd + size - 1, NACK_VAL);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

esp_err_t bme_read(i2c_port_t i2c_num, uint8_t *data_addres, uint8_t *data_rd , size_t size){
    if (size == 0) {
        return ESP_OK;
    }
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR_BME << 1) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write(cmd, data_addres, size, ACK_CHECK_EN);
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR_BME << 1) | READ_BIT, ACK_CHECK_EN);
    if (size > 1) {
        i2c_master_read(cmd, data_rd, size - 1, ACK_VAL);
    }
    i2c_master_read_byte(cmd, data_rd + size - 1, NACK_VAL);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

esp_err_t bmi_write(i2c_port_t i2c_num,uint8_t *data_addres, uint8_t *data_wr ,size_t size){
    uint8_t size1 = 1;
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR_BMI << 1) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write(cmd, data_addres, size1, ACK_CHECK_EN);
    i2c_master_write(cmd, data_wr, size, ACK_CHECK_EN);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

esp_err_t bme_write(i2c_port_t i2c_num,uint8_t *data_addres, uint8_t *data_wr ,size_t size){
    uint8_t size1 = 1;
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR_BME << 1) | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write(cmd, data_addres, size1, ACK_CHECK_EN);
    i2c_master_write(cmd, data_wr, size, ACK_CHECK_EN);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

int chipid_bmi(void){
    uint8_t reg_id=0x00;
    uint8_t tmp;
    
    bmi_read(I2C_NUM_0, &reg_id, &tmp,1);
    printf("\nvalor de CHIPID: %2X \n\n",tmp);
    if(tmp == 0x24){
        printf("Chip BMI270 reconocido.\n\n");
        return 0;
    }
    if(tmp != 0x24) {
        printf("Chip BMI270 no reconocido. \nCHIP ID: %2x\n\n", tmp); // %2X
        exit(EXIT_SUCCESS);
    }
    return 1;
}

int chipid_bme(void){
    uint8_t reg_id=0xd0;
    uint8_t tmp;
    
    ret = bme_read(I2C_NUM_0, &reg_id, &tmp, 1);
    printf("\nvalor de CHIPID: %2X \n\n",tmp);
    // printf("\nReturn del bme_read: %s \n",esp_err_to_name(ret));
    if(tmp == 0x61){
        printf("Chip BME688 reconocido.\n\n");
        return 0;
    }
    if(tmp != 0x61) {
        printf("Chip BME688 no reconocido. \nCHIP ID: %2x\n\n", tmp); // %2X
        // exit(EXIT_SUCCESS);
    }
    return 1;
}

int variantid_bme(void){
    uint8_t reg_id=0xF0;
    uint8_t tmp;
    
    ret = bme_read(I2C_NUM_0, &reg_id, &tmp, 1);
    
    // printf("\nReturn del bme_read: %s \n",esp_err_to_name(ret));
    if(tmp == 0x1){
        printf("\nvalor de VARIANT ID: %2X BME688\n",tmp);
        return 0;
    }
    if(tmp != 0x0) {
        printf("\nvalor de VARIANT ID: %2X BME680\n",tmp);
        // exit(EXIT_SUCCESS);d
    }
    return 1;
}

int softreset_bmi(void){
    uint8_t reg_softreset=0x7E, val_softreset = 0xB6;
    
    ret = bmi_write(I2C_NUM_0, &reg_softreset, &val_softreset,1);
    vTaskDelay(1000 /portTICK_PERIOD_MS);
    if(ret != ESP_OK){
        printf("\nError en softreset: %s \n",esp_err_to_name(ret));
        return 1;
    }
    else {
         printf("\nSoftreset: OK\n\n");
    }
    return 0;
}

int softreset_bme(void){
    uint8_t reg_softreset = 0xE0, val_softreset = 0xB6;
    
    ret = bme_write(I2C_NUM_0, &reg_softreset, &val_softreset,1);
    vTaskDelay(1000 /portTICK_PERIOD_MS);
    if(ret != ESP_OK){
        printf("\nError en softreset: %s \n",esp_err_to_name(ret));
        return 1;
    }
    else {
        printf("\nSoftreset: OK\n\n");
    }
    return 0;
}

void powermode(void){
    uint8_t reg_pwr_conf=0x7C, reg_pwr_ctrl=0x7D;
    uint8_t tmp,tmp2;
    
    ret= bmi_read(I2C_NUM_0, &reg_pwr_conf, &tmp,1);
    printf("valor de PWR_CONF: %2X \n",tmp);
    if(ret != ESP_OK){
        printf("Error en PWR_CONF: %s \n",esp_err_to_name(ret));
    }

    ret2= bmi_read(I2C_NUM_0, &reg_pwr_ctrl, &tmp2,1);
    printf("valor de PWR_CTRL: %2X \n",tmp2);
    if(ret2 != ESP_OK){
        printf("Error en PWR_CTRL: %s \n",esp_err_to_name(ret2));
    }
}

/*
00 = Sleep mode
01 = Forced mode 
10 = Parallel mode
*/
int8_t change_power_mode(const uint8_t op_mode){
   int8_t rslt; 
   uint8_t tmp_pow_mode;
   uint8_t pow_mode = 0;
   uint8_t reg_ctrl_meas_addr = 0x74;  
   do {
        rslt = bme_read(I2C_NUM_0, &reg_ctrl_meas_addr, &tmp_pow_mode,1);

        if (rslt == ESP_OK) {
        /* Put to sleep before changing mode */
          pow_mode = (tmp_pow_mode & 0x03);
          if (pow_mode != 0) {
                tmp_pow_mode &= ~0x03; /* Set to sleep */
                rslt = bme_write(I2C_NUM_0, &reg_ctrl_meas_addr, &tmp_pow_mode, 1);
                //vTaskDelay(1000 /portTICK_PERIOD_MS);
                //dev->delay_us(BME68X_PERIOD_POLL, dev->intf_ptr);
            }
        }   
   } while ((pow_mode != 0x0) && (rslt == ESP_OK));
    /* Already in sleep */
   if ((op_mode != 0x0) && (rslt == ESP_OK)) {
        tmp_pow_mode = (tmp_pow_mode & ~0x03) | (op_mode & 0x03);
        // printf("\ntmp_pow_mode: %2X\n", tmp_pow_mode);
        rslt = bme_write(I2C_NUM_0, &reg_ctrl_meas_addr, &tmp_pow_mode, 1);
        printf("\nModo de BME %2X escrito\n", op_mode);
   }
   return rslt;
}

void initialization_bmi(void){

    uint8_t reg_pwr_conf_advpowersave=0x7C, val_pwr_conf_advpowersave=0x00;
    uint8_t reg_init_ctrl=0x59, val_init_ctrl=0x00, val_init_ctrl2=0x01;
    uint8_t reg_init_data=0x5E; //, tmp;

    printf("Inicializando ...\n");

    bmi_write(I2C_NUM_0, &reg_pwr_conf_advpowersave, &val_pwr_conf_advpowersave,1);
    //ret= bmi_read(I2C_NUM_0, &reg_pwr_conf_advpowersave, &tmp,1);
    // if(ret != ESP_OK){
    //     printf("Error en PWR_CONF: %s \n",esp_err_to_name(ret));
    // }
    // printf("valor de PWR_CONF: %2X \n",tmp);
    
    vTaskDelay(1000 /portTICK_PERIOD_MS);

    ret=bmi_write(I2C_NUM_0, &reg_init_ctrl, &val_init_ctrl,1);
    // if(ret != ESP_OK){
    //     printf("Error en write2: %s \n",esp_err_to_name(ret));
    // }
    // else {
    //      printf("Init_ctrl = 0\n");
    // }


    int config_size = sizeof(bmi270_config_file);
    //printf("Tamano config_file: %d\n\n",config_size);

    ret=bmi_write(I2C_NUM_0, &reg_init_data, (uint8_t*)bmi270_config_file, config_size);
    if(ret != ESP_OK){
        printf("\nError cargando config_file\n");
    }
    else {
        printf("\nConfig_file cargado.\n");
    }

    vTaskDelay(1000 /portTICK_PERIOD_MS);

    ret=bmi_write(I2C_NUM_0, &reg_init_ctrl, &val_init_ctrl2,1);
    // if(ret != ESP_OK){
    //     printf("Error en write4: %s \n",esp_err_to_name(ret));
    // }
    // else {
    //      printf("Init_ctrl = 1\n");
    // }

    printf("\nAlgoritmo de inicializacion finalizado.\n\n");
    
    //vTaskDelay(1000 /portTICK_PERIOD_MS);
}

void check_initialization_bmi(void){
    uint8_t reg_internalstatus=0x21;
    uint8_t tmp;
    
    vTaskDelay(1000 /portTICK_PERIOD_MS);

    bmi_read(I2C_NUM_0, &reg_internalstatus, &tmp,1);
    printf("Init_status.0: %x \n",(tmp & 0b00001111));
    if((tmp & 0b00001111)==1){
        printf("Comprobacion Inicializacion: OK\n\n");
    }
    else {
        printf("Inicializacion fallida\n\n");
        exit(EXIT_SUCCESS);
    }
}

// void initialization_bme(void){

//     uint8_t reg_Ctrl_meas = 0x74;

//     printf("Inicializando ...\n");

    
// }

void powermode_performance(void){
    uint8_t reg_pwr_ctrl=0x7D, val_pwr_ctrl=0x0E;
    uint8_t reg_acc_conf=0x40, val_acc_conf=0xA8;
    uint8_t reg_gyr_conf=0x42, val_gyr_conf=0xE9; 
    uint8_t reg_pwr_conf=0x7C, val_pwr_conf=0x02;
    
    bmi_write(I2C_NUM_0, &reg_pwr_ctrl, &val_pwr_ctrl,1);
    bmi_write(I2C_NUM_0, &reg_acc_conf, &val_acc_conf,1);
    bmi_write(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf,1);
    bmi_write(I2C_NUM_0, &reg_pwr_conf, &val_pwr_conf,1);

    vTaskDelay(1000 /portTICK_PERIOD_MS);   

    printf("Performance power mode: activated. \n\n");
}

void powermode_normal(void){
    //PWR_CTRL: disable auxiliary sensor, gryo acc temp on
    //200Hz en datos acc, filter: performance optimized, acc_range +/-8g (1g = 9.80665 m/s2, alcance max: 78.4532 m/s2, 16 bit= 65536 => 1bit = 78.4532/32768 m/s2)
    //200Hz en datos gyro, noise filter: performance optimized, filter: performance opt., gyr_range +/-2000dps, 16.4LSB/dps (1 bit= 2000/32768 dps, 34.90659/32768 rad/s)
    uint8_t reg_pwr_ctrl=0x7D, val_pwr_ctrl=0x0E;
    uint8_t reg_acc_conf=0x40, val_acc_conf=0xA8;   
    uint8_t reg_gyr_conf=0x42, val_gyr_conf=0xA9; 
    uint8_t reg_pwr_conf=0x7C, val_pwr_conf=0x02;
    
    bmi_write(I2C_NUM_0, &reg_pwr_ctrl, &val_pwr_ctrl,1);
    bmi_write(I2C_NUM_0, &reg_acc_conf, &val_acc_conf,1);
    bmi_write(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf,1);
    bmi_write(I2C_NUM_0, &reg_pwr_conf, &val_pwr_conf,1);

    vTaskDelay(1000 /portTICK_PERIOD_MS);   

    //printf("Normal power mode: activated. \n\n");
}

void powermode_low(void){
    uint8_t reg_pwr_ctrl=0x7D, val_pwr_ctrl=0x04;
    uint8_t reg_acc_conf=0x40, val_acc_conf=0x17;
    uint8_t reg_pwr_conf=0x7C, val_pwr_conf=0x03;
    
    bmi_write(I2C_NUM_0, &reg_pwr_ctrl, &val_pwr_ctrl,1);
    bmi_write(I2C_NUM_0, &reg_acc_conf, &val_acc_conf,1);
    bmi_write(I2C_NUM_0, &reg_pwr_conf, &val_pwr_conf,1);

    vTaskDelay(1000 /portTICK_PERIOD_MS);   

    //printf("Low power mode: activated. \n\n");
}

void powermode_suspend(void){
    uint8_t reg_pwr_ctrl=0x7D, val_pwr_ctrl=0x00;
    uint8_t reg_acc_conf=0x40, val_acc_conf=0x00;
    uint8_t reg_gyr_conf=0x42, val_gyr_conf=0x00; 
    uint8_t reg_pwr_conf=0x7C, val_pwr_conf=0x01;
    
    bmi_write(I2C_NUM_0, &reg_pwr_ctrl, &val_pwr_ctrl,1);
    bmi_write(I2C_NUM_0, &reg_acc_conf, &val_acc_conf,1);
    bmi_write(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf,1);
    bmi_write(I2C_NUM_0, &reg_pwr_conf, &val_pwr_conf,1);

    vTaskDelay(1000 /portTICK_PERIOD_MS);   
}

/* This function is used to calculate the heater resistance value using integer */
static uint8_t calc_res_heat(uint16_t temp)
{
    uint8_t heatr_res;
    uint8_t amb_temp = 25;
    
    uint8_t reg_par_g1 = 0xED;
    uint8_t par_g1;
    bme_read(I2C_NUM_0, &reg_par_g1, &par_g1, 1);

    uint8_t reg_par_g2_lsb = 0xEB;
    uint8_t par_g2_lsb;
    bme_read(I2C_NUM_0, &reg_par_g2_lsb, &par_g2_lsb, 1);
    uint8_t reg_par_g2_msb = 0xEC;
    uint8_t par_g2_msb;
    bme_read(I2C_NUM_0, &reg_par_g2_msb, &par_g2_msb, 1);
    uint16_t par_g2 =
        (int16_t)(BME68X_CONCAT_BYTES(par_g2_msb, par_g2_lsb));

    uint8_t reg_par_g3 = 0xEE;
    uint8_t par_g3;
    bme_read(I2C_NUM_0, &reg_par_g3, &par_g3, 1);

    uint8_t reg_res_heat_range = 0x02;
    uint8_t res_heat_range;
    uint8_t mask_res_heat_range = (0x3 << 4);
    uint8_t tmp_res_heat_range;

    uint8_t reg_res_heat_val = 0x00;
    uint8_t res_heat_val;

    int32_t var1;
    int32_t var2;
    int32_t var3;
    int32_t var4;
    int32_t var5;
    int32_t heatr_res_x100;

    if (temp > 400) /* Cap temperature */
    {
        temp = 400;
    }

    bme_read(I2C_NUM_0, &reg_res_heat_range , &tmp_res_heat_range, 1);
    bme_read(I2C_NUM_0, &reg_res_heat_val , &res_heat_val, 1);
    res_heat_range = (mask_res_heat_range & tmp_res_heat_range)>>4;
    
    var1 = (((int32_t)amb_temp * par_g3) / 1000) * 256;
    var2 = (par_g1 + 784) * (((((par_g2 + 154009) * temp * 5) / 100) + 3276800) / 10);
    var3 = var1 + (var2 / 2);
    var4 = (var3 / (res_heat_range + 4));
    var5 = (131 * res_heat_val) + 65536;
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
    heatr_res = (uint8_t)((heatr_res_x100 + 50) / 100);

    return heatr_res;
}

/* This internal API is used to calculate the gas wait */
static uint8_t calc_gas_wait(uint16_t dur) {
    uint8_t factor = 0;
    uint8_t durval;

    if (dur >= 0xfc0) {
        durval = 0xff; /* Max duration*/
    }
    else {
        while (dur > 0x3F) {
            dur = dur >> 2;
            factor += 1;
        }

        durval = (uint8_t)(dur + (factor * 64));
    }

    return durval;
}
static uint8_t calc_heatr_dur_shared(uint16_t dur){
    uint8_t factor = 0;
    uint8_t heatdurval;

    if (dur >= 0x783){
        heatdurval = 0xff; /* Max duration */
    }else{
        /* Step size of 0.477ms */
        dur = (uint16_t)(((uint32_t)dur * 1000) / 477);
        while (dur > 0x3F){
            dur = dur >> 2;
            factor += 1;
        }
        heatdurval = (uint8_t)(dur + (factor * 64));
    }
    return heatdurval;
}


// Solo modo paralelo
uint32_t bme68x_get_meas_dur(){
    int8_t rslt;
    uint32_t meas_dur = 0; /* Calculate in us */
    uint32_t meas_cycles;

    meas_cycles = 1;
    meas_cycles += 2;
    meas_cycles += 16;

    /* TPH measurement duration */
    meas_dur = meas_cycles * (uint32_t)(1963);
    meas_dur += (uint32_t)(477 * 4); /* TPH switching duration */
    meas_dur += (uint32_t)(477 * 5); /* Gas measurement duration */
    //meas_dur += (uint32_t) 1000; /* Wake up duration of 1ms */
    return meas_dur;
}

int8_t bme_forced_mode(void) {
    // osrs_h
    uint8_t reg_osrs_h=0x72,     val_osrs_h=0x1;        // osrs_h<2:0>[2:0]
    uint8_t mask_osrs_h = 0x7; // 0x7 = 0b111
    uint8_t tmp_osrs_h;
    bme_read(I2C_NUM_0, &reg_osrs_h, &tmp_osrs_h, 1);
    val_osrs_h = (tmp_osrs_h & ~mask_osrs_h) | (val_osrs_h & mask_osrs_h);
   
    // osrs_t and osrs_p
    uint8_t reg_osrs_t_p=0x74,   val_osrs_t_p=0x15;   // osrs_t<2:0>[7:5] osrs_p<2:0>[4:2] 
    uint8_t mask_osrs_t_p = ~0x3; // ~0x3 = 0b11111100
    uint8_t tmp_osrs_t_p;
    bme_read(I2C_NUM_0, &reg_osrs_t_p, &tmp_osrs_t_p, 1);
    val_osrs_t_p = (tmp_osrs_t_p & ~mask_osrs_t_p) | (val_osrs_t_p<<2 & mask_osrs_t_p);
    
    // filter
    uint8_t reg_filter=0x75,     val_filter=0x0;        // filter<2:0>[4:2]
    uint8_t mask_filter = 0x1C; // 0x1C = 0b00011100
    uint8_t tmp_filter;
    bme_read(I2C_NUM_0, &reg_filter, &tmp_filter, 1);
    val_filter = (tmp_filter & ~mask_filter) | (val_filter<<2 & mask_filter);   
    
    //val_run_gas and nb_conv
    uint8_t reg_run_gas = 0x071; // run_gas [5:5]
    uint8_t reg_nb_conv = 0x071;     //  nb_conv <2:0> [2:0]
    uint8_t tmp_run_gas;
    bme_read(I2C_NUM_0, &reg_run_gas, &tmp_run_gas, 1);
    uint8_t run_gas_mask = 0x01 << 5;
    uint8_t run_nb_conv_mask = ~0x0 << 4 ;
    uint8_t partial_val_run_gas = (tmp_run_gas | run_gas_mask) ;
    uint8_t val_run_gas = (partial_val_run_gas & run_nb_conv_mask);  
    
    // gas_wait 
    uint8_t reg_gas_wait_0=0x64;  // gas_wait0<7:0>
    uint8_t val_reg_gas_wait_0 = calc_gas_wait(100);

    uint8_t reg_res_heat_0=0x5a;
    uint8_t val_res_heat = calc_res_heat(300);

    bme_write(I2C_NUM_0, &reg_osrs_h, &val_osrs_h,1);
    bme_write(I2C_NUM_0, &reg_osrs_t_p, &val_osrs_t_p,1);
    bme_write(I2C_NUM_0, &reg_filter, &val_filter,1);
    bme_write(I2C_NUM_0, &reg_run_gas, &val_run_gas,1); // run gas y nb_conv
    bme_write(I2C_NUM_0, &reg_gas_wait_0, &val_reg_gas_wait_0,1);
    bme_write(I2C_NUM_0, &reg_res_heat_0, &val_res_heat,1);
    int8_t rslt = change_power_mode(0b01);
    return rslt;
}

void bme_parallel_mode(void){
    // osrs_h
    uint8_t reg_osrs_h=0x72,     val_osrs_h=0x1;        // osrs_h<2:0>[2:0]
    uint8_t mask_osrs_h = 0x7; // 0x7 = 0b111
    uint8_t tmp_osrs_h;
    bme_read(I2C_NUM_0, &reg_osrs_h, &tmp_osrs_h, 1);
    val_osrs_h = (tmp_osrs_h & ~mask_osrs_h) | (val_osrs_h & mask_osrs_h);
   
    // osrs_t and osrs_p
    uint8_t reg_osrs_t_p=0x74,   val_osrs_t_p=0x15;   // osrs_t<2:0>[7:5] osrs_p<2:0>[4:2] 
    uint8_t mask_osrs_t_p = ~0x3; // ~0x3 = 0b11111100
    uint8_t tmp_osrs_t_p;
    bme_read(I2C_NUM_0, &reg_osrs_t_p, &tmp_osrs_t_p, 1);
    val_osrs_t_p = (tmp_osrs_t_p & ~mask_osrs_t_p) | (val_osrs_t_p<<2 & mask_osrs_t_p);
    
    // filter
    uint8_t reg_filter=0x75,     val_filter=0x0;        // filter<2:0>[4:2]
    uint8_t mask_filter = 0x1C; // 0x1C = 0b00011100
    uint8_t tmp_filter;
    bme_read(I2C_NUM_0, &reg_filter, &tmp_filter, 1);
    val_filter = (tmp_filter & ~mask_filter) | (val_filter<<2 & mask_filter);   
    
    //val_run_gas and nb_conv
    uint8_t reg_run_gas = 0x071; // run_gas [5:5]
    uint8_t reg_nb_conv = 0x071;     //  nb_conv <2:0> [2:0]
    uint8_t tmp_run_gas;
    bme_read(I2C_NUM_0, &reg_run_gas, &tmp_run_gas, 1);
    uint8_t run_gas_mask = 0x01 << 5;
    // uint8_t run_nb_conv_mask = ~0x0 << 4 ;
    uint8_t run_nb_conv_mask = 0xf;
    uint8_t partial_val_run_gas = (tmp_run_gas | run_gas_mask) ;
    uint8_t val_run_gas = (partial_val_run_gas | run_nb_conv_mask);  
    
    // gas_shared
    uint8_t reg_gas_shared = 0x6E;
    uint8_t val_gas_shared = 0x59;
    bme_write(I2C_NUM_0, &reg_gas_shared, &val_gas_shared, 1);
    
    // gas_wait_x
    uint16_t mul_prof[10] = { 5, 2, 10, 30, 5, 5, 5, 5, 5, 5 };
    for (uint8_t reg_gas_wait=0x64; reg_gas_wait <= 0x6D; reg_gas_wait++){
        uint8_t val_reg = mul_prof[reg_gas_wait - 0x64];
        bme_write(I2C_NUM_0, &reg_gas_wait, &val_reg, 1);
    }
    uint8_t reg_gas_wait_0=0x64, val_reg_gas_wait_0=0x59;   // gas_wait0<7:0>
    
    // gas_wait_shared
    uint8_t reg_gas_wait_shared = 0x6E;
    uint16_t shared_heatr_dur = (uint16_t)(140 - (bme68x_get_meas_dur()/ 1000));
    uint8_t shared_dur = calc_heatr_dur_shared(shared_heatr_dur);
    bme_write(I2C_NUM_0, &reg_gas_wait_shared, &shared_dur, 1);

    // heatr
    uint16_t temp_prof[10] = { 320, 100, 100, 100, 200, 200, 200, 320, 320, 320 };
    for(uint8_t reg_heat = 0x5A; reg_heat <= 0x63; reg_heat++){
        uint8_t val_reg = calc_res_heat(temp_prof[reg_heat - 0x5A]);
        printf("res_heat_%d = %2X\n", reg_heat - 0x5A, val_reg);
        bme_write(I2C_NUM_0, &reg_heat, &val_reg, 1);
    }

    bme_write(I2C_NUM_0, &reg_osrs_h, &val_osrs_h,1);
    bme_write(I2C_NUM_0, &reg_osrs_t_p, &val_osrs_t_p,1);
    bme_write(I2C_NUM_0, &reg_filter, &val_filter,1);
    bme_write(I2C_NUM_0, &reg_run_gas, &val_run_gas,1);
    // bme_write(I2C_NUM_0, &reg_nb_conv, &val_nb_conv,1);
    bme_write(I2C_NUM_0, &reg_gas_wait_0, &val_reg_gas_wait_0,1);
    // bme_write(I2C_NUM_0, &reg_res_heat_0, &,1);
    int8_t mode = change_power_mode(0b10);
}

int fetch_data_idx = 0;
bme68x_data* fetch_data(bme68x_data *data[]){
    bme68x_data *fetched_data = data[fetch_data_idx];
    fetch_data_idx = (fetch_data_idx + 1) % 3;
    return fetched_data;
}

void internal_status(void){
    uint8_t reg_internalstatus=0x21;
    uint8_t tmp;

    bmi_read(I2C_NUM_0, &reg_internalstatus, &tmp,1);
    printf("Internal Status: %2X\n\n", tmp);

}

/* @brief This internal API is used to calculate the temperature value. */
static int32_t calc_temperature(uint8_t reg_adc_temp_xlsb, uint8_t reg_adc_temp_lsb, uint8_t reg_adc_temp_msb) {
    // par_t1
    uint8_t reg_par_t1_lsb = 0xE9;
    uint8_t par_t1_lsb;
    bme_read(I2C_NUM_0, &reg_par_t1_lsb, &par_t1_lsb, 1);
    uint8_t reg_par_t1_msb = 0xEA;
    uint8_t par_t1_msb;
    bme_read(I2C_NUM_0, &reg_par_t1_msb, &par_t1_msb, 1);
    uint16_t par_t1 =
        (uint16_t)(BME68X_CONCAT_BYTES(par_t1_msb, par_t1_lsb));

    // par_t2
    uint8_t reg_par_t2_lsb = 0x8A;
    uint8_t par_t2_lsb;
    bme_read(I2C_NUM_0, &reg_par_t2_lsb, &par_t2_lsb, 1);
    uint8_t reg_par_t2_msb = 0x8B;
    uint8_t par_t2_msb;
    bme_read(I2C_NUM_0, &reg_par_t2_msb, &par_t2_msb, 1);
    uint16_t par_t2 =
        (int16_t)(BME68X_CONCAT_BYTES(par_t2_msb, par_t2_lsb));

    // par_t3
    uint8_t reg_par_t3 = 0x8C;
    uint8_t par_t3;
    bme_read(I2C_NUM_0, &reg_par_t3, &par_t3, 1);

    // adc_temp
    // uint8_t reg_adc_temp_xlsb = 0x24; // <7:4> 
    uint8_t adc_temp_xlsb;
    bme_read(I2C_NUM_0, &reg_adc_temp_xlsb, &adc_temp_xlsb, 1);
    
    // uint8_t reg_adc_temp_lsb = 0x23; 
    uint8_t adc_temp_lsb;
    bme_read(I2C_NUM_0, &reg_adc_temp_lsb, &adc_temp_lsb, 1);
    
    // uint8_t reg_adc_temp_msb = 0x22;
    uint8_t adc_temp_msb;
    bme_read(I2C_NUM_0, &reg_adc_temp_msb, &adc_temp_msb, 1);

    uint32_t adc_temp = (uint32_t)(((uint32_t)adc_temp_msb << 12) | ((uint32_t)adc_temp_lsb << 4) | ((uint32_t)adc_temp_xlsb >> 4));

    int64_t var1 = 0; // cuando tengas el temp_comp me lo pasas pls xd
    int64_t var2 = 0;
    int64_t var3 = 0;
    int32_t calc_temp = 0;

    /*lint -save -e701 -e702 -e704 */
    var1 = ((int32_t)adc_temp >> 3) - ((int32_t)par_t1 << 1);
    var2 = (var1 * (int32_t)par_t2) >> 11;
    var3 = ((var1 >> 1) * (var1 >> 1)) >> 12;
    var3 = ((var3) * ((int32_t)par_t3 << 4)) >> 14;
    t_fine = (int32_t)(var2 + var3);
    calc_temp = (((t_fine * 5) + 128) >> 8);

    /*lint -restore */
    return calc_temp;
}

static uint32_t calc_pressure(uint32_t t_fine, uint8_t reg_adc_pres_xlsb, uint8_t reg_adc_pres_lsb, uint8_t reg_adc_pres_msb){
       
    uint8_t reg_par_p1_lsb = 0x8E;
    uint8_t tmp_par_p1_lsb = 0; 
    bme_read(I2C_NUM_0, &reg_par_p1_lsb, &tmp_par_p1_lsb, 1);
    uint8_t reg_par_p1_msb = 0x8F;
    uint8_t tmp_par_p1_msb = 0;
    bme_read(I2C_NUM_0, &reg_par_p1_msb, &tmp_par_p1_msb, 1);
    //par_p1 
    uint16_t par_p1 = (((uint16_t) tmp_par_p1_msb << 8) | (uint16_t) tmp_par_p1_lsb); 
    
    uint8_t reg_par_p2_lsb = 0x90;
    uint8_t tmp_par_p2_lsb = 0;
    bme_read(I2C_NUM_0, &reg_par_p2_lsb, &tmp_par_p2_lsb, 1);
    uint8_t reg_par_p2_msb = 0x91;
    uint8_t tmp_par_p2_msb = 0;
    bme_read(I2C_NUM_0, &reg_par_p2_msb, &tmp_par_p2_msb, 1);
    //par_p2
    uint16_t par_p2 = (((uint16_t) tmp_par_p2_msb << 8) | (uint16_t) tmp_par_p2_lsb); 
    
    //par_p3
    uint8_t reg_par_p3 = 0x92;
    uint8_t par_p3 = 0;
    bme_read(I2C_NUM_0, &reg_par_p3, &par_p3, 1);

    uint8_t reg_par_p4_lsb = 0x94;
    uint8_t tmp_par_p4_lsb = 0;
    bme_read(I2C_NUM_0, &reg_par_p4_lsb, &tmp_par_p4_lsb, 1);
    uint8_t reg_par_p4_msb = 0x95;
    uint8_t tmp_par_p4_msb = 0;
    bme_read(I2C_NUM_0, &reg_par_p4_msb, &tmp_par_p4_msb, 1);
    //par_p4
    uint16_t par_p4 = (((uint16_t) tmp_par_p4_msb << 8) |(uint16_t)tmp_par_p4_lsb);

    
    uint8_t reg_par_p5_lsb = 0x96;
    uint8_t tmp_par_p5_lsb = 0;
    bme_read(I2C_NUM_0, &reg_par_p5_lsb, &tmp_par_p5_lsb, 1);
    uint8_t reg_par_p5_msb = 0x97;
    uint8_t tmp_par_p5_msb = 0;
    bme_read(I2C_NUM_0, &reg_par_p5_msb, &tmp_par_p5_msb, 1);
    //par_p5
    uint16_t par_p5 = (((uint16_t) tmp_par_p5_msb << 8) | (uint16_t)tmp_par_p5_lsb);

    //par_p6
    uint8_t reg_par_p6 = 0x99;
    uint8_t par_p6 = 0;
    bme_read(I2C_NUM_0, &reg_par_p6, &par_p6, 1);

     //par_p7
    uint8_t reg_par_p7 = 0x98;
    uint8_t par_p7 = 0;
    bme_read(I2C_NUM_0, &reg_par_p7, &par_p7, 1);

    uint8_t reg_par_p8_lsb = 0x9C;
    uint8_t tmp_par_p8_lsb = 0;
    bme_read(I2C_NUM_0, &reg_par_p8_lsb, &tmp_par_p8_lsb, 1);
    uint8_t reg_par_p8_msb = 0x9D;
    uint8_t tmp_par_p8_msb = 0;
    bme_read(I2C_NUM_0, &reg_par_p8_msb, &tmp_par_p8_msb, 1);
    //par_p8
    uint16_t par_p8 = (((uint16_t) tmp_par_p8_msb << 8) | (uint16_t) tmp_par_p8_lsb);

    uint8_t reg_par_p9_lsb = 0x9E;
    uint8_t tmp_par_p9_lsb = 0;
    bme_read(I2C_NUM_0, &reg_par_p9_lsb, &tmp_par_p9_lsb, 1);
    uint8_t reg_par_p9_msb = 0x9F;
    uint8_t tmp_par_p9_msb = 0;
    bme_read(I2C_NUM_0, &reg_par_p9_msb, &tmp_par_p9_msb, 1);
    //par_p9
    uint16_t par_p9 = (((uint16_t) tmp_par_p9_msb << 8) | (uint16_t) tmp_par_p9_lsb);

    //par_p10
    uint8_t reg_par_p10 = 0xA0;
    uint8_t par_p10 = 0;
    bme_read(I2C_NUM_0, &reg_par_p10, &par_p10, 1);

    //press_adc
    // uint8_t reg_adc_pres_xlsb = 0x21;
    // uint8_t reg_adc_pres_lsb = 0x20;
    // uint8_t reg_adc_pres_msb = 0x1F;
    uint8_t tmp_lsb = 0;
    uint8_t tmp_medium = 0;
    uint8_t tmp_msb = 0;
    bme_read(I2C_NUM_0, &reg_adc_pres_xlsb, &tmp_lsb, 1);
    bme_read(I2C_NUM_0, &reg_adc_pres_lsb, &tmp_medium, 1);
    bme_read(I2C_NUM_0, &reg_adc_pres_msb, &tmp_msb, 1);
    uint32_t lsb = (0x000000F0 & (uint32_t)tmp_lsb) >> 4;
    uint32_t medium = (((uint32_t) tmp_medium) << 4);
    uint32_t msb = (((uint32_t) tmp_msb) << 12);
    uint32_t pres_adc =(msb|medium|lsb);

    int32_t var1 = 0;
    int32_t var2 = 0;
    int32_t var3 = 0;
    int32_t pressure_comp = 0;

    /* This value is used to check precedence to multiplication or division
     * in the pressure compensation equation to achieve least loss of precision and
     * avoiding overflows.
     * i.e Comparing value, pres_ovf_check = (1 << 31) >> 1
     */
    const int32_t pres_ovf_check = INT32_C(0x40000000);

    /*lint -save -e701 -e702 -e713 */
    var1 = (((int32_t)t_fine) >> 1) - 64000;
    var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)par_p6) >> 2;
    var2 = var2 + ((var1 * (int32_t)par_p5) << 1);
    var2 = (var2 >> 2) + ((int32_t)par_p4 << 16);
    var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)par_p3 << 5)) >> 3) +
           (((int32_t)par_p2 * var1) >> 1);
    var1 = var1 >> 18;
    var1 = ((32768 + var1) * (int32_t)par_p1) >> 15;
    pressure_comp = 1048576 - pres_adc;
    pressure_comp = (int32_t)((pressure_comp - (var2 >> 12)) * ((uint32_t)3125));
    if (pressure_comp >= pres_ovf_check)
    {
        pressure_comp = ((pressure_comp / var1) << 1);
    }
    else
    {
        pressure_comp = ((pressure_comp << 1) / var1);
    }

    var1 = ((int32_t)par_p9 * (int32_t)(((pressure_comp >> 3) * (pressure_comp >> 3)) >> 13)) >> 12;
    var2 = ((int32_t)(pressure_comp >> 2) * (int32_t)par_p8) >> 13;
    var3 =
        ((int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) * (int32_t)par_p10) >> 17;
    pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 + ((int32_t)par_p7 << 7)) >> 4);

    /*lint -restore */
    return (uint32_t)pressure_comp;
}

/* This internal API is used to calculate the humidity in integer */
static uint32_t calc_humidity(int32_t temp_scaled, uint8_t reg_adc_hum_lsb, uint8_t reg_adc_hum_msb) {
    uint8_t reg_par_h1_lsb = 0xE2;// <3:0>
    uint8_t reg_par_h1_msb = 0xE3;
    uint8_t tmp_val_par_h1_lsb = 0;
    uint8_t tmp_val_par_h1_msb = 0;
    bme_read(I2C_NUM_0, &reg_par_h1_lsb, &tmp_val_par_h1_lsb, 1);
    bme_read(I2C_NUM_0, &reg_par_h1_msb, &tmp_val_par_h1_msb, 1);
    uint16_t lsb_h1 = (0x0F & tmp_val_par_h1_lsb);
    uint16_t msb_h1 = (((uint16_t) tmp_val_par_h1_msb) << 4);
    //par_h1
    uint16_t val_par_h1 = (msb_h1 | lsb_h1);
    
    uint8_t reg_par_h2_msb = 0xE1;
    uint8_t tmp_val_par_h2_msb = 0;
    bme_read(I2C_NUM_0, &reg_par_h2_msb, &tmp_val_par_h2_msb, 1);
    uint16_t lsb_h2 = (0xF0 & tmp_val_par_h1_lsb) >> 4;
    uint16_t msb_h2 = (((uint16_t) tmp_val_par_h2_msb) << 4);
    //par_h2
    uint16_t val_par_h2 = (msb_h2 | lsb_h2);
    
    uint8_t reg_par_h3 = 0xE4;
    int8_t val_par_h3 = 0;
    bme_read(I2C_NUM_0, &reg_par_h3, (uint8_t *)&val_par_h3, 1);

    uint8_t reg_par_h4 = 0xE5;
    int8_t val_par_h4 = 0;
    bme_read(I2C_NUM_0, &reg_par_h4, (uint8_t *)&val_par_h4, 1);

    uint8_t reg_par_h5 = 0xE6;
    int8_t val_par_h5 = 0;
    bme_read(I2C_NUM_0, &reg_par_h5, (uint8_t *)&val_par_h5, 1);

    uint8_t reg_par_h6 = 0xE7;
    uint8_t val_par_h6 = 0;
    bme_read(I2C_NUM_0, &reg_par_h6, &val_par_h6, 1);

    uint8_t reg_par_h7 = 0xE8;
    int8_t val_par_h7 = 0;
    bme_read(I2C_NUM_0, &reg_par_h7, (uint8_t *)&val_par_h7, 1);

    // uint16_t reg_adc_hum_lsb = 0x26;   //FIELD 0
    uint8_t tmp_adc_hum_lsb = 0;
    bme_read(I2C_NUM_0, &reg_adc_hum_lsb, &tmp_adc_hum_lsb, 1);
    // uint16_t reg_adc_hum_msb = 0x25;
    uint8_t tmp_adc_hum_msb = 0;
    bme_read(I2C_NUM_0, &reg_adc_hum_msb, &tmp_adc_hum_msb, 1);
    uint16_t adc_hum = (((uint16_t) tmp_adc_hum_msb << 8) | (uint16_t) tmp_adc_hum_lsb);
    
    //temp_scaled = (((int32_t)dev->calib.t_fine * 5) + 128) >> 8;
    int32_t var1 = (int32_t)(adc_hum - ((int32_t)((int32_t)val_par_h1 * 16))) -
           (((temp_scaled * (int32_t)val_par_h3) / ((int32_t)100)) >> 1);
    int32_t var2 =
        ((int32_t)val_par_h2 *
         (((temp_scaled * (int32_t)val_par_h4) / ((int32_t)100)) +
          (((temp_scaled * ((temp_scaled * (int32_t)val_par_h5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
          (int32_t)(1 << 14))) >> 10;
    int32_t var3 = var1 * var2;
    int32_t var4 = (int32_t)val_par_h6 << 7;
    var4 = ((var4) + ((temp_scaled * (int32_t)val_par_h7) / ((int32_t)100))) >> 4;
    int32_t var5 = ((var3 >> 14) * (var3 >> 14)) >> 10;
    int32_t var6 = (var4 * var5) >> 1;
    int32_t calc_hum = ((var3 + var6) >> 12); 
    calc_hum = (((var3 + var6) >> 10) * ((int32_t)1000)) >> 12;
    //printf("calc_hum (int32) = %lu\n", calc_hum); // 1111010011010001     // 62673
    if (calc_hum > 100000) /* Cap at 100%rH */          // 1111010011110011     // 62707
    {
        calc_hum = 100000;
    }
    else if (calc_hum < 0)
    {
        calc_hum = 0;
    }
    /*lint -restore */
    return (uint32_t) calc_hum;
}

/* This internal API is used to calculate the gas resistance */
static uint32_t calc_gas_resistance_high(uint8_t reg_adc_gas_lsb, uint8_t reg_adc_gas_msb, uint8_t reg_gas_range_h) {
    // adc_gas_res_high
    // uint8_t reg_adc_gas_lsb = 0x2D; // <7:6>
    uint8_t adc_gas_res_high_lsb;
    bme_read(I2C_NUM_0, &reg_adc_gas_lsb, &adc_gas_res_high_lsb, 1);
    // uint8_t reg_adc_gas_msb = 0x2C;
    uint8_t adc_gas_res_high_msb;
    bme_read(I2C_NUM_0, &reg_adc_gas_msb, &adc_gas_res_high_msb, 1);
    uint16_t adc_gas_res_high = (uint16_t) ((uint32_t) adc_gas_res_high_msb << 2 | (((uint32_t) adc_gas_res_high_lsb) >> 6));
    
    // gas_range_h
    // uint8_t reg_gas_range_h = 0x2D; // <3:0>
    uint8_t gas_range_h;
    bme_read(I2C_NUM_0, &reg_gas_range_h, &gas_range_h, 1);
    gas_range_h = gas_range_h & 0x0f;
    
    uint32_t calc_gas_res = 0;
    uint32_t var1 = UINT32_C(262144) >> gas_range_h;
    int32_t var2 = (int32_t)adc_gas_res_high - INT32_C(512);

    var2 *= INT32_C(3);
    var2 = INT32_C(4096) + var2;

    /* multiplying 10000 then dividing then multiplying by 100 instead of multiplying by 1000000 to prevent overflow */
    calc_gas_res = (UINT32_C(10000) * var1) / (uint32_t)var2;
    calc_gas_res = calc_gas_res * 100;

    return calc_gas_res;
}

static int8_t read_all_field_data(bme68x_data *data[]) {
    int8_t rslt = ESP_OK;
    // uint8_t buff[BME68X_LEN_FIELD * 3] = { 0 };
    // uint8_t gas_range_l, gas_range_h;
    // uint32_t adc_temp;
    // uint32_t adc_pres;
    // uint16_t adc_hum;
    // uint16_t adc_gas_res_low, adc_gas_res_high;
    // uint8_t off;
    uint8_t set_val[30] = { 0 }; /* idac, res_heat, gas_wait */
    uint8_t i;

    if (!data[0] && !data[1] && !data[2])
    {
        rslt = -1;
    }

    // if (rslt == BME68X_OK)
    // {
    //     rslt = bme68x_get_regs(BME68X_REG_FIELD0, buff, (uint32_t) BME68X_LEN_FIELD * 3, dev);
    // }

    // if (rslt == BME68X_OK)
    // {
    //     rslt = bme68x_get_regs(BME68X_REG_IDAC_HEAT0, set_val, 30, dev);
    // }

    for (i = 0; i < 3; i++) {
        //Status
        uint8_t reg_status;
        uint8_t tmp_status;
        uint8_t status;

        //gas_index
        uint8_t gas_index;

        //sub_meas_index
        uint8_t reg_sub_meas_index;
        uint8_t tmp_sub_meas_index;
        uint8_t sub_meas_index;

        // temp
        uint8_t reg_adc_temp_xlsb;
        uint8_t reg_adc_temp_lsb;
        uint8_t reg_adc_temp_msb;

        // pres
        uint8_t reg_adc_pres_xlsb;
        uint8_t reg_adc_pres_lsb;
        uint8_t reg_adc_pres_msb;

        // hum
        uint8_t reg_adc_hum_lsb;
        uint8_t reg_adc_hum_msb;

        // gas
        uint8_t reg_adc_gas_lsb;
        uint8_t reg_adc_gas_msb;
        uint8_t reg_gas_range_h;

        if (i==0) {
            //Fields 0
            //status
            reg_status = 0x1D;
            uint8_t tmp_status;
            bme_read(I2C_NUM_0, &reg_status, &tmp_status, 1);
            status = ((tmp_status & 0x80) >> 7);

            //gas_index
            gas_index = (tmp_status & 0x0f);

            //sub_meas_index
            reg_sub_meas_index = 0x1E;
            uint8_t tmp_sub_meas_index;
            bme_read(I2C_NUM_0, &reg_sub_meas_index, &tmp_sub_meas_index, 1);
            sub_meas_index = tmp_sub_meas_index;

            // temp
            reg_adc_temp_xlsb = 0x24;
            reg_adc_temp_lsb = 0x23;
            reg_adc_temp_msb = 0x22;

            // pres
            reg_adc_pres_xlsb = 0x21;
            reg_adc_pres_lsb = 0x20;
            reg_adc_pres_msb = 0x1F;

            // hum
            reg_adc_hum_lsb = 0x26;
            reg_adc_hum_msb = 0x25;

            // gas
            reg_adc_gas_lsb = 0x2D; //<7:6>
            reg_adc_gas_msb = 0x2C;
            reg_gas_range_h = 0x2D; //<3:0>
            
        } else if (i==1) {
            //status FIELD 1
            reg_status = 0x2E;
            uint8_t tmp_status;
            bme_read(I2C_NUM_0, &reg_status, &tmp_status, 1);
            status = ((tmp_status & 0x80) >> 7);

            //gas_index
            gas_index = (tmp_status & 0x0f);

            //sub_meas_index
            reg_sub_meas_index = 0x2f;
            uint8_t tmp_sub_meas_index;
            bme_read(I2C_NUM_0, &reg_sub_meas_index, &tmp_sub_meas_index, 1);
            sub_meas_index = tmp_sub_meas_index;
            
            // temp
            reg_adc_temp_xlsb = 0x35;
            reg_adc_temp_lsb = 0x34;
            reg_adc_temp_msb = 0x33;

            // pres
            reg_adc_pres_xlsb = 0x32;
            reg_adc_pres_lsb = 0x31;
            reg_adc_pres_msb = 0x30;

            // hum
            reg_adc_hum_lsb = 0x37;
            reg_adc_hum_msb = 0x36;

            // gas
            reg_adc_gas_lsb = 0x3E;
            reg_adc_gas_msb = 0x3D;
            reg_gas_range_h = 0x3E;

        } else {
            //status FIELD 2
            reg_status = 0x3F;
            uint8_t tmp_status;
            bme_read(I2C_NUM_0, &reg_status, &tmp_status, 1);
            status = ((tmp_status & 0x80) >> 7);

            //gas_index
            gas_index = (tmp_status & 0x0f);

             //sub_meas_index
            reg_sub_meas_index = 0x40;
            uint8_t tmp_sub_meas_index;
            bme_read(I2C_NUM_0, &reg_sub_meas_index, &tmp_sub_meas_index, 1);
            sub_meas_index = tmp_sub_meas_index;

            // temp
            reg_adc_temp_xlsb = 0x46;
            reg_adc_temp_lsb = 0x45;
            reg_adc_temp_msb = 0x44;

            // pres
            reg_adc_pres_xlsb = 0x43;
            reg_adc_pres_lsb = 0x42;
            reg_adc_pres_msb = 0x41;

            // hum
            reg_adc_hum_lsb = 0x48;
            reg_adc_hum_msb = 0x47;

            // gas
            reg_adc_gas_lsb = 0x4F; //<7:6>
            reg_adc_gas_msb = 0x4E;  
            reg_gas_range_h = 0x4F; //<3:0>
        }

        data[i]->status = status;
        data[i]->gas_index = gas_index;
        data[i]->meas_index = sub_meas_index;

        data[i]->idac = set_val[data[i]->gas_index];
        data[i]->res_heat = set_val[10 + data[i]->gas_index];
        data[i]->gas_wait = set_val[20 + data[i]->gas_index];

        int32_t temperature = calc_temperature(reg_adc_temp_xlsb, reg_adc_temp_lsb, reg_adc_temp_msb);
        uint32_t pressure = calc_pressure(t_fine, reg_adc_pres_xlsb, reg_adc_pres_lsb, reg_adc_pres_msb);
        uint32_t humidity = calc_humidity(temperature, reg_adc_hum_lsb, reg_adc_hum_msb);
        uint32_t gas = calc_gas_resistance_high(reg_adc_gas_lsb, reg_adc_gas_msb, reg_gas_range_h);
        data[i]->temperature = temperature;
        data[i]->pressure = pressure;
        data[i]->humidity = humidity;
        data[i]->gas_resistance = gas;
    }

    return rslt;
}

float rms_value(int16_t *l, int n){
    float square = 0;
    float mean;
    float root;
    for (int i =0; i < n; i++){
        square += pow(((float) l[i]),2);
    }
    mean = (square / (float) (n));
    root = sqrt(mean);
    return root;
}

typedef struct {
    float real;
    float imag;
} complejo;

void calcularFFT(int16_t *entrada_amplitud_tiempo, int longitud, float frecuencia_muestreo, complejo *salida_fft) {
    for (int k = 0; k < longitud; k++) {
        salida_fft[k].real = 0;
        salida_fft[k].imag = 0;

        for (int n = 0; n < longitud; n++) {
            float angulo = 2 * M_PI * k * n / longitud;
            float cos_angulo = cos(angulo);
            float sin_angulo = -sin(angulo);

            salida_fft[k].real += ((float) entrada_amplitud_tiempo[n]) * cos_angulo;
            salida_fft[k].imag += ((float) entrada_amplitud_tiempo[n]) * sin_angulo;
        }
    }
    for (int i = 0; i < longitud; i++) {
        salida_fft[i].real /= longitud;
        salida_fft[i].imag /= longitud;
    }
    
}

void printFFT(complejo *fft, int longitud) {
    for (int i = 0; i < longitud-1; i++) {
        printf("%f,%f;", fft[i].real, fft[i].imag);
    }
    printf("%f,%f", fft[longitud-1].real, fft[longitud-1].imag);
}

int compare_int16(const void *a, const void *b){
    int16_t num1 = *((int16_t *) a);
    int16_t num2 = *((int16_t *) b);
    return num1 - num2;
}

int compare_int32(const void *a, const void *b){
    int32_t num1 = *((int32_t *) a);
    int32_t num2 = *((int32_t *) b);
    return num1 - num2;
}

int compare_uint32(const void *a, const void *b){
    uint32_t num1 = *((uint32_t *) a);
    uint32_t num2 = *((uint32_t *) b);
    return num1 - num2;
}

int compare_float(const void *a, const void *b){
    float num1 = *((float *) a);
    float num2 = *((float *) b);
    return num1 - num2;
}

void sort_int16(int16_t * l){
    qsort(l,20,sizeof(l[0]),compare_int16);
}

void sort_int32(int32_t * l){
    qsort(l,20,sizeof(l[0]),compare_int32);
}

void sort_uint32(uint32_t * l){
    qsort(l,20,sizeof(l[0]),compare_uint32);
}

void sort_float(float *l){
    qsort(l, 20,sizeof(l[0]),compare_float);
}

void print5Peaks_16b(int16_t *l){
    printf("%hd\t%hd\t%hd\t%hd\t%hd&",l[19],l[18],l[17],l[16],l[15]);
}


void print5Peaks_float(float *l){
    printf("%f\t%f\t%f\t%f\t%f&",l[19],l[18],l[17],l[16],l[15]);
}

void print5Peaks_32b(int32_t *l){
    printf("%ld\t%ld\t%ld\t%ld\t%ld&",l[19],l[18],l[17],l[16],l[15]);
}

void print5Peaks_32unsigned(uint32_t *l){
    printf("%lu\t%lu\t%lu\t%lu\t%lu&",l[19],l[18],l[17],l[16],l[15]);
}

int lectura_bmi(uint8_t bytes_to_read){
    uint8_t reg_intstatus=0x03, tmp;
    uint8_t reg_data = 0x0C, data_data8[bytes_to_read];
    int16_t acc_x, acc_y, acc_z, gyr_x, gyr_y, gyr_z;
    acc_x = acc_y = acc_z = gyr_x = gyr_y = gyr_z = 0;
    int samples = 20;
    int16_t ax[samples], ay[samples], az[samples], gx[samples], gy[samples], gz[samples];
    
    // int interations = 10;

    char dataResponse1[8];
    while (1){
        
        int rLen = serial_read_timeout(dataResponse1, 8, 50);
        if (rLen > 0) {
            if (strcmp(dataResponse1, "MODIFY_") == 0) {
                break;
            }
            if (strcmp(dataResponse1, "RESET__") == 0) {
                return 1;
            }
        }

        bmi_read(I2C_NUM_0, &reg_intstatus, &tmp,1);
        //ESP_LOGI("leturabmi", "acc_data_ready: %x - mask(80): %x \n", tmp, (tmp & 0b10000000));

        for(int i=0; i<samples; i++){
            if ((tmp & 0b10000000) == 0x80){ 
                ret= bmi_read(I2C_NUM_0, &reg_data, (uint8_t*) data_data8, bytes_to_read);
                if(ret != ESP_OK){
                    printf("Error lectura: %s \n",esp_err_to_name(ret));
                }
                
                if (bytes_to_read > 5){
                    acc_x = ((uint16_t) data_data8[1] << 8) | (uint16_t) data_data8[0];
                    acc_y = ((uint16_t) data_data8[3] << 8) | (uint16_t) data_data8[2];
                    acc_z = ((uint16_t) data_data8[5] << 8) | (uint16_t) data_data8[4];
                }
                if (bytes_to_read  == 12){
                    gyr_x = ((uint16_t) data_data8[7] << 8) | (uint16_t) data_data8[6];
                    gyr_y = ((uint16_t) data_data8[9] << 8) | (uint16_t) data_data8[8];
                    gyr_z = ((uint16_t) data_data8[11] << 8) | (uint16_t) data_data8[10];
                }
                
                ax[i] = acc_x;
                ay[i] = acc_y;
                az[i] = acc_z;
                gx[i] = gyr_x;
                gy[i] = gyr_y;
                gz[i] = gyr_z;
            }
        }

        complejo ft_ax[samples];
        complejo ft_ay[samples];
        complejo ft_az[samples];
        complejo ft_gx[samples];
        complejo ft_gy[samples];
        complejo ft_gz[samples];

        calcularFFT(ax, samples, 200, ft_ax);
        calcularFFT(ay, samples, 200, ft_ay);
        calcularFFT(az, samples, 200, ft_az);
        calcularFFT(gx, samples, 200, ft_gx);
        calcularFFT(gy, samples, 200, ft_gy);
        calcularFFT(gz, samples, 200, ft_gz);

        float rms_ax = rms_value(ax, samples);
        float rms_ay = rms_value(ay, samples);
        float rms_az = rms_value(az, samples);
        float rms_gx = rms_value(gx, samples);
        float rms_gy = rms_value(gy, samples);
        float rms_gz = rms_value(gz, samples);

        // ESTAMOS MANDANDO ÚLTIMO DATO CRUDO, DEBE SER TODA LA LISTA
        printf("<%hd\t%hd\t%hd\t%hd\t%hd\t%hd|%f\t%f\t%f\t%f\t%f\t%f|", acc_x, acc_y, acc_z, gyr_x, gyr_y, gyr_z, rms_ax, rms_ay, rms_az, rms_gx, rms_gy, rms_gz);
        printFFT(ft_ax, samples);
        printf("\t");
        printFFT(ft_ay, samples);
        printf("\t");
        printFFT(ft_az, samples);
        printf("\t");
        printFFT(ft_gx, samples);
        printf("\t");
        printFFT(ft_gy, samples);
        printf("\t");
        printFFT(ft_gz, samples);
        printf("|");

        sort_int16(ax);
        sort_int16(ay);
        sort_int16(az);
        sort_int16(gx);
        sort_int16(gy);
        sort_int16(gz);

        print5Peaks_16b(ax);
        print5Peaks_16b(ay);
        print5Peaks_16b(az);
        print5Peaks_16b(gx);
        print5Peaks_16b(gy);
        print5Peaks_16b(gz);
        printf(">");
    }
    return 0;
}

void printArray_16(int16_t *l, int n){
    for (int i =0; i < n; i++){
        printf("%hd\t", l[i]);
    }
    printf("&");
}

void printArray_float(float *l, int n){
    for (int i =0; i < n; i++){
        printf("%.3f\t", l[i]);
    }
    printf("&");
}

void printArray_32unsigned(uint32_t *l, int n){
    for (int i =0; i < n; i++){
        printf("%lu\t", l[i]);
    }
    printf("&");
}

void lectura_bme(uint8_t mode){
    int samples = 20;
    float h[samples], t[samples];
    uint32_t  p[samples], g[samples];
    // bme68x_data * parallel_data[3];
    // for(int i=0; i<3; i++){
    //     parallel_data[i] = malloc(sizeof(struct bme68x_data));
    // }

    struct bme68x_data *field_ptr[3] = { 0 };
    struct bme68x_data field_data[3] = { { 0 } };

    field_ptr[0] = &field_data[0];
    field_ptr[1] = &field_data[1];
    field_ptr[2] = &field_data[2];

    bme68x_data *fetched_data;
    uint32_t temperature;
    uint32_t pressure;
    uint32_t humidity;
    uint32_t gas;
    char dataResponse1[8];
    while (1){
        // printf("<lectura_bme>");
        // int rLen = serial_read_timeout(dataResponse1, 8, 50);
        // if (rLen > 0) {
        //     if (strcmp(dataResponse1, "MODIFY_") == 0) {
        //         break;
        //     }
        // }
        if(mode == 2) bme_parallel_mode();

        for(int i=0; i<samples; i++) {
            int rLen = serial_read_timeout(dataResponse1, 8, 5);
            if (rLen > 0) {
                if (strcmp(dataResponse1, "MODIFY_") == 0) {
                    return;
                }
            }

            if (mode == 1){
                bme_forced_mode();
                vTaskDelay(pdMS_TO_TICKS(50)); // delay real: se cree que es 41590 microsegundos = 41.59 ms

                // temp
                uint8_t reg_adc_temp_xlsb = 0x24;
                uint8_t reg_adc_temp_lsb = 0x23;
                uint8_t reg_adc_temp_msb = 0x22;

                // pres
                uint8_t reg_adc_pres_xlsb = 0x21;
                uint8_t reg_adc_pres_lsb = 0x20;
                uint8_t reg_adc_pres_msb = 0x1F;

                // hum
                uint8_t reg_adc_hum_lsb = 0x26;
                uint8_t reg_adc_hum_msb = 0x25;

                // gas
                uint8_t reg_adc_gas_lsb = 0x2D; //<7:6>
                uint8_t reg_adc_gas_msb = 0x2C;
                uint8_t reg_gas_range_h = 0x2D; //<3:0>

                temperature = calc_temperature(reg_adc_temp_xlsb, reg_adc_temp_lsb, reg_adc_temp_msb);
                pressure = calc_pressure(t_fine, reg_adc_pres_xlsb, reg_adc_pres_lsb, reg_adc_pres_msb);
                humidity = calc_humidity(temperature, reg_adc_hum_lsb, reg_adc_hum_msb);
                gas = calc_gas_resistance_high(reg_adc_gas_lsb, reg_adc_gas_msb, reg_gas_range_h);
            } else if(mode == 2){
                if (!fetch_data_idx){
                    // bme_parallel_mode();
                    read_all_field_data(field_ptr);
                    vTaskDelay(pdMS_TO_TICKS(50));
                }
                fetched_data = fetch_data(field_ptr);
                temperature = fetched_data->temperature;
                pressure = fetched_data->pressure;
                humidity = fetched_data->humidity;
                gas = fetched_data->gas_resistance;
                // i += 2;
                // i = i > 19? 0 : i;
            } else {
                continue;
            }
            t[i] = (float)temperature/100;
            h[i] = (float)humidity/1000;
            p[i] = pressure;
            g[i] = gas;
            
        }


        
        printf("<");
        printArray_float(t, samples); 
        printArray_float(h, samples); 
        printArray_32unsigned(p, samples); 
        printArray_32unsigned(g, samples); 
        printf("|");
        
        sort_float(t);
        sort_float(h);
        sort_uint32(p);
        sort_uint32(g);

        print5Peaks_float(t);
        print5Peaks_float(h); 
        print5Peaks_32unsigned(p);//unsigned
        print5Peaks_32unsigned(g);
        printf(">");
    

        // printf("\nTemperatura del BME: %f °C\n", (float)temperature/100);   
        // printf("\nHumedad del BME: %f g/m³\n", (float)humidity/1000);
        // printf("\nPresión del BME: %ld Pa\n", pressure);
        // printf("\nCO del BME: %ld ppm\n", gas);
    }
    // for(int i=0; i<3; i++){
    //     free(parallel_data[i]);
    // }
}

void debug_register_log(char* mode){
    uint8_t reg_pwr_ctrl=0x7D, val_pwr_ctrl;
    uint8_t reg_acc_conf=0x40, val_acc_conf;   
    uint8_t reg_gyr_conf=0x42, val_gyr_conf; 
    uint8_t reg_pwr_conf=0x7C, val_pwr_conf;
    bmi_read(I2C_NUM_0, &reg_pwr_ctrl, &val_pwr_ctrl,1);
    bmi_read(I2C_NUM_0, &reg_acc_conf, &val_acc_conf,1);
    bmi_read(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf,1);
    bmi_read(I2C_NUM_0, &reg_pwr_conf, &val_pwr_conf,1);
    printf("<{=================================\nMode : %s\n", mode);
    printf("PWR_CTRL: %2X\n", val_pwr_ctrl);
    printf("ACC_CONF: %2X\n", val_acc_conf);
    printf("GYR_CONF: %2X\n", val_gyr_conf);
    printf("PWR_CONF: %2X\n", val_pwr_conf);
    printf("ACC_ODR : %2X\n", val_acc_conf & 0b00001111);
    printf("GYR_ODR : %2X\n", val_gyr_conf & 0b00001111);
    printf("=================================}>\n");
}

enum Device {NO_DEVICE, BME688, BMI270};
enum Device DEVICE = NO_DEVICE;

void test_bme_forced() {
    ESP_ERROR_CHECK(bme_init());
    
    if(chipid_bme() == 0){ // BME Connected
            variantid_bme();
            softreset_bme();
    }        
    else {
        printf("bme not connected");
        return;
    }

    int samples = 20;

    uint32_t temperature;
    uint32_t pressure;
    uint32_t humidity;
    uint32_t gas;


    for(int i=0; i<samples; i++) {
        bme_forced_mode();
        vTaskDelay(pdMS_TO_TICKS(5000));

        // temp
        uint8_t reg_adc_temp_xlsb = 0x24;
        uint8_t reg_adc_temp_lsb = 0x23;
        uint8_t reg_adc_temp_msb = 0x22;

        // pres
        uint8_t reg_adc_pres_xlsb = 0x21;
        uint8_t reg_adc_pres_lsb = 0x20;
        uint8_t reg_adc_pres_msb = 0x1F;

        // hum
        uint8_t reg_adc_hum_lsb = 0x26;
        uint8_t reg_adc_hum_msb = 0x25;

        // gas
        uint8_t reg_adc_gas_lsb = 0x2D; //<7:6>
        uint8_t reg_adc_gas_msb = 0x2C;
        uint8_t reg_gas_range_h = 0x2D; //<3:0>

        temperature = calc_temperature(reg_adc_temp_xlsb, reg_adc_temp_lsb, reg_adc_temp_msb);
        pressure = calc_pressure(t_fine, reg_adc_pres_xlsb, reg_adc_pres_lsb, reg_adc_pres_msb);
        humidity = calc_humidity(temperature, reg_adc_hum_lsb, reg_adc_hum_msb);
        gas = calc_gas_resistance_high(reg_adc_gas_lsb, reg_adc_gas_msb, reg_gas_range_h);

        printf("\nTemperatura del BME: %f °C\n", (float)temperature/100);   
        printf("\nHumedad del BME: %f %%\n", (float)humidity/1000);
        printf("\nPresión del BME: %ld Pa\n", pressure);
        printf("\nCO del BME: %ld Ohms\n", gas);
        
    }
}

void test_bme_parallel() {
    ESP_ERROR_CHECK(bme_init());
    
    if(chipid_bme() == 0){ // BME Connected
            variantid_bme();
            softreset_bme();
    }        
    else {
        printf("bme not connected");
        return;
    }

    int samples = 20;
    float h[samples], t[samples];
    uint32_t  p[samples], g[samples];
    bme68x_data parallel_data[3];

    struct bme68x_data *field_ptr[3] = { 0 };
    struct bme68x_data field_data[3] = { { 0 } };

    field_ptr[0] = &field_data[0];
    field_ptr[1] = &field_data[1];
    field_ptr[2] = &field_data[2];

    // for(int i=0; i<3; i++){
    //     parallel_data[i] = malloc(sizeof(struct bme68x_data));
    // }
    bme68x_data *fetched_data;
    uint32_t temperature;
    uint32_t pressure;
    uint32_t humidity;
    uint32_t gas;

    bme_parallel_mode();

    for(int i=0; i<samples; i++) {
        if (!fetch_data_idx){
            // bme_parallel_mode();
            vTaskDelay(pdMS_TO_TICKS(50));
            read_all_field_data(field_ptr);
        }
        
        fetched_data = fetch_data(field_ptr);
        temperature = fetched_data->temperature;
        pressure = fetched_data->pressure;
        humidity = fetched_data->humidity;
        gas = fetched_data->gas_resistance;
        // i += 2;
        // i = i > 19? 0 : i;

        t[i] = (float)temperature/100;
        h[i] = (float)humidity/1000;
        p[i] = pressure;
        g[i] = gas;
        printf("\nTemperatura del BME: %f °C\n", (float)temperature/100);   
        printf("\nHumedad del BME: %f %%\n", (float)humidity/1000);
        printf("\nPresión del BME: %ld Pa\n", pressure);
        printf("\nCO del BME: %ld Ohms\n", gas);
        
    }
    // for(int i=0; i<3; i++){
    //     free(&parallel_data[i]);
    // }
}

void main_logic(){
    while (1){
        DEVICE = NO_DEVICE;
        if(chipid_bme() == 0){ // BME Connected
            variantid_bme();
            softreset_bme();
            // pr
            
            DEVICE = BME688;
        } else if (chipid_bmi() == 0){ // BMI Connected
            softreset_bmi();
            initialization_bmi();
            check_initialization_bmi();
            powermode_normal();
            internal_status();
            DEVICE = BMI270;
        }
        if (DEVICE) break;
    }
    
    // Do depending on device
    while(1){
        if (DEVICE == BME688){
            uint8_t reg_mode=0x74;
            uint8_t tmp;
            
            ret = bme_read(I2C_NUM_0, &reg_mode, &tmp, 1);

            tmp = tmp & 0x3;
            
            printf("valor de BME MODE: %2X \n\n",tmp);
            printf("\nReturn del bme_read: %s \n",esp_err_to_name(ret));
            char dataResponse1[8];
            char *powermode = "Normal";

            uint8_t bme_mode = 1;
            while(1){
                //printf("<read>\n");
                int rLen = serial_read(dataResponse1, 8);
                if (rLen > 0){
                    if (strcmp(dataResponse1, "BEGIN__") == 0){
                        // uart_write_bytes(UART_NUM,"OK\0",3);
                        if (DEBUG) {
                            debug_register_log(powermode);
                            vTaskDelay(pdMS_TO_TICKS(1000));  
                        }
                        break;
                    }
                    if (strcmp(dataResponse1, "ID_____") == 0){
                        printf("BME688\n");
                        continue;
                    }
                    if(strcmp(dataResponse1, "RESET__") == 0){
                        return;
                    }
                    char mode[4];
                    char selected[3];
                    strncpy(mode, dataResponse1, 3);
                    strncpy(selected, dataResponse1 + 3, 2);
                    printf("<{command mode: %s, selected: %s}>\n", mode, selected);
                    vTaskDelay(pdMS_TO_TICKS(1000));  
                    if (strcmp(mode, "PWR") == 0){
                        printf("{POWERMODE CHANGING}\n");
                        if (strcmp(selected, "#1") == 0){
                            printf("{FORCED ENGAGED}\n");
                            bme_mode = 1;
                            powermode = "Forzed";
                        }
                        if (strcmp(selected, "#2") == 0){
                            printf("{PARALLEL ENGAGED}\n");
                            bme_mode = 2;
                            powermode = "Parallel";
                        }
                        if (strcmp(selected, "#3") == 0){
                            printf("{SUSPEND ENGAGED}\n");
                            bme_mode = 3;
                            powermode = "Suspend";
                        }

                    }
                }
            }
            printf("<{INICIANDO LECTURA}>");
            lectura_bme(bme_mode);
        } 
        else if (DEVICE == BMI270){
            // Waiting for an BEGIN to initialize data sending
            char dataResponse1[8];
            char *powermode = "Normal";
            int reading = 1;
            while(reading){
                uint8_t bytes_to_read = 12;
                while (1){
                    int rLen = serial_read(dataResponse1, 8);
                    if (rLen > 0){
                        if (strcmp(dataResponse1, "BEGIN__") == 0){
                            // uart_write_bytes(UART_NUM,"OK\0",3);
                            if (DEBUG) {
                                debug_register_log(powermode);
                                vTaskDelay(pdMS_TO_TICKS(1000));  
                            }
                            break;
                        } 
                        if (strcmp(dataResponse1, "ID_____") == 0){
                            printf("BMI270\n");
                            continue;
                        }
                        if(strcmp(dataResponse1, "RESET__") == 0){
                            return;
                        }
                        char mode[4];
                        char selected[3];
                        strncpy(mode, dataResponse1, 3);
                        strncpy(selected, dataResponse1 + 3, 2);
                        printf("{command mode: %s, selected: %s}\n", mode, selected);
                        vTaskDelay(pdMS_TO_TICKS(1000));  
                        if (strcmp(mode, "PWR") == 0){
                            printf("{POWERMODE CHANGING}\n");
                            if (strcmp(selected, "#1") == 0){
                                printf("{LOW ENGAGED}\n");
                                powermode_low();
                                powermode = "Low";
                                bytes_to_read = 6;
                            }
                            if (strcmp(selected, "#2") == 0){
                                printf("{NORMAL ENGAGED}\n");
                                powermode_normal();
                                powermode = "Normal";
                                bytes_to_read = 12;
                            }
                            if (strcmp(selected, "#3") == 0){
                                printf("{PERFORMANCE ENGAGED}\n");
                                powermode_performance();
                                powermode = "Performance";
                                bytes_to_read = 12;
                            }
                            if (strcmp(selected, "#4") == 0){
                                printf("{SUSPEND ENGAGED}\n");
                                powermode_suspend();
                                powermode = "suspend";
                                bytes_to_read = 0;
                            }
                        }
                        if (strcmp(mode, "ODR") == 0){
                            char level[2];
                            strncpy(level, selected +1, 1);
                            int code = strtol(level, NULL, 16);
                            uint8_t old = 0; uint8_t new = 0;
                            if (code > 0 && code < 13){ 
                                uint8_t reg_acc_conf=0x40, val_acc_conf;
                                bmi_read(I2C_NUM_0, &reg_acc_conf, &val_acc_conf, 1);
                                old = val_acc_conf;
                                val_acc_conf = (val_acc_conf & 0b11110000) | code;
                                new = val_acc_conf;
                                bmi_write(I2C_NUM_0, &reg_acc_conf, &val_acc_conf, 1);
                                printf("{ODR ACC changed %2X -¬ %2X}\n", old, new);
                            }
                            strncpy(selected, dataResponse1 + 5, 2);
                            strncpy(level, selected +1, 1);
                            code = strtol(level, NULL, 16);
                            if (code > 5 && code < 14){
                                uint8_t reg_gyr_conf=0x42, val_gyr_conf; 
                                bmi_read(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf, 1);
                                old = val_gyr_conf;
                                val_gyr_conf = (val_gyr_conf & 0b11110000) | code;
                                new = val_gyr_conf;
                                bmi_write(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf, 1);
                                printf("{ODR GYR changed %2X -¬ %2X}\n", old, new);
                            }
                        }
                        if (strcmp(mode, "SNS") == 0){
                            char level[2];
                            strncpy(level, selected +1, 1);
                            int code = strtol(level, NULL, 16);
                            uint8_t old = 0; uint8_t new = 0;
                            if (code > -1 && code < 4){ 
                                uint8_t reg_acc_conf=0x41, val_acc_conf;
                                bmi_read(I2C_NUM_0, &reg_acc_conf, &val_acc_conf, 1);
                                old = val_acc_conf;
                                val_acc_conf = (val_acc_conf & 0b11111100) | code;
                                new = val_acc_conf;
                                bmi_write(I2C_NUM_0, &reg_acc_conf, &val_acc_conf, 1);
                                printf("{SNS ACC changed %2X -¬ %2X}\n", old, new);
                            }
                            strncpy(selected, dataResponse1 + 5, 2);
                            strncpy(level, selected +1, 1);
                            code = strtol(level, NULL, 16);
                            if (code > -1 && code < 5){
                                uint8_t reg_gyr_conf=0x43, val_gyr_conf; 
                                bmi_read(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf, 1);
                                old = val_gyr_conf;
                                val_gyr_conf = (val_gyr_conf & 0b11111000) | code;
                                new = val_gyr_conf;
                                bmi_write(I2C_NUM_0, &reg_gyr_conf, &val_gyr_conf, 1);
                                printf("{SNS GYR changed %2X -¬ %2X}\n", old, new);
                            }
                        }
                    }
                }

                reading = !lectura_bmi(bytes_to_read);
            }
            

            printf("Beginning initialization... \n");

        }
    }
}


// Main
void app_main() {
    // test_bme_forced();
    //test_bme_parallel(); 

    uart_setup(); // Uart setup
    ESP_ERROR_CHECK(i2c_init());
    while(1){
        main_logic();
    }   
}